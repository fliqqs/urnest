- handle enum/scoped enum with fixed type

- handle using base class method/member
  - eg handle using xju::Exception; in derived class see REVISIT in hcp/tags

x handle scoped enum (non-fixed type)

- hcp-split handle inline constructor eg
  struct X {
    inline X() {...};
  };

- hcp-tags
  x need multiple defs per tag eg for function overload
  - generate tags for:
    x class
    x template class
    x global function
    x simple typedef
    x global var decl
    x global var def
    x namespace
    x enum X{ ... };
    - class enum
    - enum members
    - hash define
    - typedef + anon enum
    - typedef + named enum
    - typedef + anon struct/class
    - typedef + named struct/class
    - template specialisation v template
    - skip anonymous namespaces (perhaps does already?)
  - test on .hh and .hcp file types

x when excluding class/struct/union/enum/namespace keywords need to ensure
  it is not them being used to start a valid identifer, eg class_1 f();

- hcp-split copy copyright notice to .cc? (optional?)

- hcp-scope-at
    x need a way to capture scope at EndOfFile where partially parsed
    x think we just need to capture a list of completed items when
      we hit end of input eg as a std::vector<IR> - should be able to
      capture in Exception
    x only need to add to that in "and" parser? ie add all the ones we've
      done already? (might also need zeroOrMore, parseUntil, atLeastOne?)
      No, only and, the others don't affect scope.
    x we would end up with something like:
           x, x, x, NamespaceName, x, ClassName, y, z, ClassName, x, x
    x then hcp-scope-at-offset just runs through and collects the interesting
      ones (NamespaceName, ClassName, EnumName, any others?)
    x add optional<vector<IR>> to exception, set conditionally when
      catch xju::parse::IteratorAdaptor::EndOfInput
    x extend in and exception handler
    - rename irsAtEnd to scopeIrsAtEnd or just scopeIrs
    x tests:
      global scope after namespace
      global scope after class
      namespace scope
      class scope
      enum scope
      namespace+class+enum scope
          
- hcp split generate operator< (and others) where there is an operator<
  function prototype (ie no implementation)
  - need to better parse attr decls to get attr names
      attr decl is typeid unqualifiedName optional(array decl)
      typeid is qualifiers (const, static) typename qualifiers (const & *)
      type_name is ok as-is I think
      eg int x;
         const int x;
         const int* x;
         const int* const x;
         int& x;
         int const x;
         int const& x;
         ... and all those replacing int by x::y<int const&>
         ... and also appending [], [3], [x::size]
      ... watch out for int const_x;
      ... or function*, eg:
         typeid (*unqualifiedName)(params);
         typeid (* const unqualifiedName)(params);
         typeid (const * unqualifiedName)(params);
         typeid (*& unqualifiedName)(params);
         ... is throw clause allowed?

      x bracketed(x)=literal("(")+eatwhite+x+parseLiteral(")")+eatwhite
      x cv_keyword=(keyword("const")|keyword("volatile"))
      x type_qual=const_keyword|volatile_keyword|(oneOfChars("*&")+eatwhite)
      x type_ref=cv + typename + zeroOrMore*type_qual
      x array_decl=parseLiteral("[")+balanced(parseLiteral("]")
      x var_initialiser -> var_init_1|var_init_2
      x var_init_1="="+parseUntil(';,')
      x var_init_2="{"+parseUntil('}')
      x var_non_fp
      x var_fp
      x param
      x params
      function_proto=flquals+type_ref+name+bracketed(params)+frquals
      function_decl=function_proto+optional(|pure_virtual|deleted)+";"
      function_def=function_proto+(impl)

      - ensure A b=C(3) does not match function proto
      
  - need to better parse function proto to get param types
  - then look for friend bool operator< with 2x params of type = class name
    (possibly const/ref qualified)

- zeroOrMore()*x -> zeroOrMore(x)

- parser + "xxx" short-hand for parser+parseLiteral("xxx")

- handle // comments anywhere, eg:
  class A  // comment
  {
  };
  ... should already parse ok? split trouble?

x fix forward-declared classes, eg:
  class A {
    class B;
  }
  class A::B {
  }

- test nested class defs v parse.cc line 85
  class A{
    class B{};
  };

x handle class "operator X()" functions (conversion operator)

- add trailing blank lines to end of entities, but add inline leading blanks
  to start of entities, to get nicer split code formatting

* when generating .cc for class member function, qualify return type
  if it was defined by the class, eg test generate of:
  struct X{
    struct Y{};
    Y f();
  };

x add option to turn off file+line tracking for generated .hh as it
  causes unnecessary recompilation of dependencies (could generate a
  separate map, but would then need editor or compiler to recognise and
  map errors) - note no file+line tracking is defualt .hh

x fix generation of friend functions
  x generate them always inline
  - later split them, but that is perhaps impossible since it
    means re-qualifying param types and it is not possible to tell how much
    to add to each param type?

* no such thing as static var decl, it is a def? for hcp-split, yet, but
  want to be able to parse .hh too

- param default values

x static member object:
    static const char* const _user_exns[] = {
      0
    };

- global (variant of above, or same? could just do "object decl") and
  let context show whether it is a class member or global?

x recognise template specialisation class
x split it properly

x recognise template specialisation function
x split it properly

x test-JoiningIterator

x replace xju::Exception with parser specific exception, that
  uses Parser* as context, to defer string creation until exception
  is actually formatted
x defer cause creation, resurrect specific cause strings
x fix string literal parsing:
  x no need to do continuations
  x do it character-based with specials as per c++ standard

- add literal(char) and use it instead of oneOfChars("x")

x make readableRepr smarter to get better error messages, so that
  other tools get the full exception context to work with:
  x only show named parsers, except always show the last parser
    context

- rework atLeastOne for saner error message - see REVISIT in test-parse.cc

x add zeroOrOne (perhaps call it optional?) and review where to use it
- rework Optional::parse_, should be to avoid copying the "good" result?

- replace more zeroOrMore with parseUntil(match,x)

x get rid of includeAllExceptionContext (make it always true)

x on parse failure, output the branch that got furthest
  x note that only exceptions are xju::Exception thrown explicitly in
    parser.cc/hh
  x replace with Malfomed exception that has at and can carry
    other fail branches

- also to get better errors need to make use of keywords, eg
  if have "class" but what follows is not a class, want that error
  message, not the error message that tries to parse eg function at
  that point. ie fail parseFunction because function cannot start with
  keyword class (or template, namespace, enum etc)
  x try using "longest branch" as error
  - add lookingAt(classIntro)+mustBe(classDecl|classDef)
    ... where mustBe raises a "final" exception - no more options are tried
  - where multiple longest branches, combine their causes
  - combine with prepending ! parseKeyword() to parseFunction
  
- I -> hcp::I in I.h

- hcp_ast::String -> Tagged..<StringTag>?

- align ast names with C++ standard

- add more profiling, then go back to using throw for exceptions
  and see what the penalty

- function_proto looks like it would be slow as it does a long
  lookahead, is there another way? Might need a hand-coded parser?
  - hand code:
    parseBalanced(oneOfChars("(;="))+literal('(')
    ... then refine to one of:
      operator<> etc
      conversion operator
      else get function name by working backwards (assumes no comment
      between name and '(')
    ... except it does not work for function pointer eg
        int (*f)(int q);
    ... so I think have no choice than to correctly parse type and then do
        cons/dest
        [static] var_type (*ident)( balanced ) [= balanced];
        [static] var_type (*ident)( balanced )\[balanced\] [= balanced];
        [static] var_type name [=balanced];
        [static] var_type name\[balanced\] [=balanced];
        [template-preamble] [inline|static|friend] ret_type operator=( balanced );
        [template-preamble] [inline|static|friend] ret_type operator=( balanced );
        [template-preamble] [inline|static|friend] ret_type name( balanced );
        [template-preamble] [inline|static|friend] ret_type name( balanced ){ balanced }
	ret_type:
	  T
	  int
	  Q< balanced >
	  X*
	  X const *
	  X *const
	  X const *const
	  X&
	  X const
          const X* etc
          ie zeroOrMore(const_keyword|volatile_keyword)+
	     identifier+zeroOrOne*templateArgs+
	     zeroOrMore(const_keyword|volatile_keyword|star|amp)
        var_type same as return type (same enough)
	
  - perhaps commonality between function and object decl? both start
    with type and name? what is difference to function pointer?
  - how often is it tried (and failed) in practice?
  
- optimisations:
  - disallow preprocessor #include inside namespace (minor)
  - ParseOneOfChars use bitset
  - ParseAnyCharExcept use bitset
  - pass I by const ref to parse_
  - hand-code unqualifiedName
  - add !identifierContChar to namespace_keyword etc, does it affect perf?
  
x speed parsing by caching results <at,parser> => PV or exception
  stats:
xju@xjutv:/data/xju/u1/urnest/hcp$ time ./hcp-parse-file test/xju/JoiningIterator.hcp 
end at line 146 column 1

real    0m2.320s
user    0m2.100s
sys     0m0.024s

* see if using std::vector<std::set<Parser*> > as Cache improves
  performance (ie source file offset is vector index)

xju@xjutv:/data/xju/u1/urnest/hcp$ ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
10391

xju@xjutv:/data/xju/u1/urnest/hcp$ ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | fgrep '[ parse comments at line 139 column 22' | wc -l
40

... after adding cache...

xju@xjutv:/data/xju/u1/urnest/hcp$ time ./hcp-parse-file test/xju/JoiningIterator.hcp 
end at line 146 column 1

real    0m0.926s
user    0m0.908s
sys     0m0.008s
xju@xjutv:/data/xju/u1/urnest/hcp$ ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
2055
xju@xjutv:/data/xju/u1/urnest/hcp$ ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | fgrep '[ parse comments at line 139 column 22' | wc -l
1

- still very slow, need to profile or at least look through the output
  to see why
    x parse namespace and anon-namespace before function, object as
      namespace starts with keyword
         ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
         end at line 146 column 1

         real	0m0.891s
         user	0m0.864s
         sys	0m0.016s
         2001


    ~ group keywords together? That would make it harder to read the
      code
    - create parsers for such keywords as namespace, template, class
      so can cache results
      - bundle them up into parseKeyword, and add a operator!()
        then make parseFunction start with !parseKeyword
       
    x probably slow through use of C++ exceptions, could switch to using
      return types, noting that at the moment we only have a single
      exception type (xju::Exception)... note to support tools eg
      context-at-point we probably need something more sophisticated
      than xju::Exception but worry about that later (actually above
      proposes to replace with Malformed)
      x think just need to redefine Parser methods to throw() and
        return the CachedResult type? Could rename it to ParseResult?
      x perhaps fork a version to test performance difference
branch nothrow, got about 20% better:
xju@xjutv:/data/xju/u1/urnest/hcp$ ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
end at line 146 column 1

real    0m0.714s
user    0m0.700s
sys     0m0.004s
1951

    ~ perhaps also look at deferring creation of exception strings until
      actually needed... but first get profiling data, might need to
      parse many times to get decent stats

    x saved lots of time by reworking the -v (includeAllExceptionContext)
      handling, since it was adding and discarding lots of context

    x reworked to defer generating context strings until exception
      printed:

-*- mode: compilation; default-directory: "/home/xju/urnest/hcp/" -*-
Compilation started at Sat Jun 28 23:11:00

ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
end at line 146 column 1

real	0m0.160s
user	0m0.124s
sys	0m0.008s
1951

... some work toward delayed exception cause strings:

xju@xjutv:~/urnest/hcp$ ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
end at line 146 column 1

real    0m0.149s
user    0m0.132s
sys     0m0.008s
1951

    x above includes all exception detail, except that "or" only keeps
      the term that got furthest, alas the resulting error messages
      are too verbose (see test-parser.cc), ideas:
        - context given for "and" should not go past the term where we
          actually failed
          ~ if exception context was a PR we could dynamically make
            one that included just the relevant part; we could also
            do better with the "or" case
          ~ perhaps revisit which parsers add context, perhaps go back
            to having just named parsers add context; but also keep
            the "leaf" context
    ~ do first pass without creating any exception detail, then
      come back and reparse from where we went wrong in order to get
      exception detail... no don't need that complex, just delay
      string creation, always add context and make readableRepr smart


latest performance check:
ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
end at line 146 column 1

real	0m0.147s
user	0m0.132s
sys	0m0.004s
1951

... hmm it has gone up a bit (commit e5166b14):

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l
end at line 146 column 1

real	0m0.160s
user	0m0.148s
sys	0m0.000s
2659


... gone up lots now (note this includes a switch from gcc 4 to gcc 5.2):

-*- mode: compilation; default-directory: "/home/xju/urnest/hcp/" -*-
Compilation started at Fri Jul 22 13:43:19

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l && git log | head -1
end at line 146 column 1

real	0m0.268s
user	0m0.232s
sys	0m0.008s
3099
commit d98c65bdbdfd2f875d4b33935e92aab53db6ae18

Compilation finished at Fri Jul 22 13:43:21

... new pc (re-baseline):

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l && git log | head -1
end at line 146 column 1

real	0m0.178s
user	0m0.172s
sys	0m0.004s
2278
commit 247ac28702ea5d82d1eb3ae6654696e3d40a04c2

... hcp-scope-at:

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l && git log | head -1
end at line 146 column 1

real	0m0.203s
user	0m0.196s
sys	0m0.004s
2268
commit 0cd1a32c9576ef06cb7f86debe62247a88b54194

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l && git log | head -1
end at line 146 column 1

real	0m0.211s
user	0m0.204s
sys	0m0.004s
2275
commit b1180d3b6d0c32332217defad2394bc8e2dff925

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file test/xju/JoiningIterator.hcp && ./hcp-parse-file -t test/xju/JoiningIterator.hcp  | wc -l && git log | head -1
end at line 146 column 1

real	0m0.191s
user	0m0.188s
sys	0m0.000s
2249
commit 8fcf2bb1e800fdfa75045e6d40f7fa7fc5ba307e


empty file overhead:

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file /dev/null && ./hcp-parse-file -t /dev/null  | wc -l
end at line 1 column 1

real	0m0.010s
user	0m0.004s
sys	0m0.000s
13

  ... hcp-scope-at:

ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file /dev/null && ./hcp-parse-file -t /dev/null  | wc -l && git log | head -1
end at line 1 column 1

real	0m0.012s
user	0m0.008s
sys	0m0.000s
13
commit 0cd1a32c9576ef06cb7f86debe62247a88b54194

   ... add impl/header detection to scopeAt:
ODINVERIFYLEVEL=0 odin maxbuilds=4 "%all" && ODINVERIFYLEVEL=0 odin maxbuilds=4 "hcp-parse-file" && time ./hcp-parse-file /dev/null && ./hcp-parse-file -t /dev/null  | wc -l && git log | head -1
end at line 1 column 1

real	0m0.012s
user	0m0.008s
sys	0m0.000s
13
commit 8fcf2bb1e800fdfa75045e6d40f7fa7fc5ba307e
   
--------- create gcc 5.2 linux cache --------------
xju@xjutv:~/urnest$ ODIN_CXX_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib  ODIN_CXX_PATH=/home/xju/gcc-5.2.0-run/bin:/usr/bin:/bin ODIN_CXX_FLAGS=-std=c++11 ODIN_EXEC_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib ODIN_CXX_I=/usr/local/omniORB-4.2.0/include ODIN_LIB_SP="/usr/local/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/usr/local/omniORB-4.2.0/bin:/bin:/usr/bin ODIN_OMNICXY_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be ./odin/create-linux-cache.sh $ODIN
