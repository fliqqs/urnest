// Copyright (c) 2017 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <hcp/tags/Namespace.hh>

#include <hcp/parser.hh>
#include <utility>

#include <xju/stringToUInt.hh> //impl
#include <hcp/ast.hh> //impl
#include "xju/assert.hh" //impl
#include <string>
#include <xju/readFile.hh>
#include <xju/path.hh>

namespace hcp
{
namespace tags
{

namespace
{
using namespace hcp_parser;

PR eatWhite(zeroOrMore*whitespaceChar);
PR openBrace(eatWhite+parseLiteral("{")+eatWhite);
hcp_parser::PR stringValue(parseUntil(doubleQuote));
struct SymbolTag{};
typedef hcp::ast::TaggedCompositeItem<SymbolTag> Symbol;
PR symbol(new NamedParser<Symbol>(
            "symbol",
            stringValue));
struct FileNameTag{};
typedef hcp_parser::ast::TaggedCompositeItem<FileNameTag> FileName;
PR fileName(new NamedParser<FileName>(
              "file name",
              stringValue));

class LineNumber : public hcp::ast::Item
{
public:
  LineNumber(std::vector<IR> const& items) throw(xju::Exception):
      CompositeItem(items),
      lineNumber_(xju::stringToUInt str())
  {
  }
  hcp::tags::LineNumber const lineNumber_;
  operator hcp::tags::LineNumber() const throw()
  {
    return lineNumber_;
  }
};
  

PR lineNumber(new NamedParser<LineNumber>(
                "line number",
                atLeastOne*charInRange('0','9')));

PR openBrace(parseLiteral("{"));
PR closeBrace(parseLiteral("}"));
PR f(parseLiteral("f"));
PR colon(parseLiteral(":"));
PR comma(parseLiteral(","));

struct LocationTag{};
typedef hcp::ast::TaggedCompositeItem<LocationTag> Location;
PR location(new NamedParser<Location>(
              "location",
              openBrace+eatWhite+doubleQuote+f+doubleQuote+eatWhite+colon+
              doubleQuote+fileName+doubleQuote+eatWhite+comma+eatWhite+
              doubleQuote+l+doubleQuote+eatWhite+colon+
              lineNumber+eatWhite+closeBrace+eatWhite));

PR openSquare(parseLiteral("["));
PR closeSquare(parseLiteral("]"));

PR locations=openSquare+eatWhite+location+eatWhite+
  zeroOrMore*(comma+eatWhite+location)+
  closeSquare+eatWhite);

struct EntryTag{};
typedef hcp::ast::TaggedCompositeItem<EntryTag> Entry;
PR entry(new NamedParser<Entry>(
           "entry",
           doubleQuote+symbol+doubleQuote+eatWhite+
           colon+eatWhite+locations));


PR tagsFile=openBrace+eatWhite+
  ((closeBrace+eatWhite)|
   (entry+eatWhite+zeroOrMore*(comma+eatWhite+entry)+closeBrace+eatWhite))+
  endOfFile;

template<class T>
T const& find(hcp_ast::IRs::const_iterator begin,
              hcp_ast::IRs::const_iterator end)
  throw() {
  auto const i(hcp_ast::find1stInTree(begin,end,
                                      [](IR x) { return x.isA<T>(); }));
  xju::assert_not_equal(i,end);
  return (*i)->asA<T>();
}
}


// augment rootNamespace with symbols from file
void augmentRootNamespace(Namespace& rootNamespace,
                          std::pair<AbsolutePath, FileName> const& tagsFile,
                          bool const traceParser)
  throw(
    // pre: rootNamespace == rootNamespace@pre
    xju::Exception) {
  try {
    std::string const x(xju::readFile(xju::path::str(tagsFile)));
    hcp_parser::I i(x.begin(), x.end());
    hcp_ast::CompositeItem root;
    hcp_parser::Cache(new hcp_parser::CacheVal);
    hcp_parser::Options const parser_options(
      traceParser,
      cache,
      false);
    
    hcp_parser::parse(root, i, tagsFile, parser_options);

    for(auto x:root.items_) {
      if (x->isA<Entry>()) {
        Entry const& entry(x->asA<Entry>());
        Symbol const& symbol(
          find<Symbol>(entry.items_.begin(),entry.items_.end()));
        std::vector<hcp::tags::Location> locations;
        for(auto x:entry.items_) {
          if (x->isA<Location>()) {
            Location const& location((*i)->asA<Location>());
            auto f(find<FileName>(location.items_.begin(),
                                  location.items_.end()));
            auto l(find<LineNumber>(location.items_.begin(),
                                    location.items_.end()));
            auto fileName(xju::path::split(f.str()));
            locations.push_back(hcp::tags::Location(
                                  fileName.first,
                                  fileName.second,
                                  l));
          }
        }
        auto const ns(splitSymbol(symbol.str()));
        rootNamespace.addSymbol(ns.first,ns.second,locations);
      }
    }
  }
  catch(xju::Exception& e) {
    std::ostringstream s;
    s << "augment namespace with symbols from tags file "
      << xju::path::str(tagsFile);
    e.addContext(s.str(),XJU_TRACED);
    throw;
  }
}

}
}
