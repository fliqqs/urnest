// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <vector>
#include <hcp/tags/NamespaceName.hh>
#include <hcp/tags/UnqualifiedSymbol.hh>
#include <hcp/tags/Location.hh>
#include <hcp/tags/Header.hh>
#include <hcp/tags/FoundIn.hh>
#include "xju/Exception.hh"
#include <map>
#include <algorithm> //impl
#include <utility>
#include "xju/next.hh" //impl
#include <sstream> //impl
#include <xju/format.hh> //impl

namespace hcp
{
namespace tags
{

// Represents a namespace, which might contain symbols and child namespaces.
// not thread safe
class Namespace
{
public:
  // record locations of namespace_::symbol
  // - appends to any existing locations
  void addSymbol(std::vector<NamespaceName> const& namespace_,
                 UnqualifiedSymbol const& symbol,
                 std::vector<Location> const& locations,
                 std::vector<Header> const& headers) throw() {
    Namespace& n(findNamespace( {namespace_.begin(),namespace_.end()} ));
    auto i=n.symbols_.find(symbol);
    if (i==n.symbols_.end()) {
      i=n.symbols_.insert( {symbol,FoundIn(Locations(),Headers()) }).first;
    }
    std::copy(locations.begin(),locations.end(),
              std::back_inserter((*i).second.locations_));
    std::copy(headers.begin(),headers.end(),
              std::back_inserter((*i).second.headers_));
  }
  void addSymbol(std::vector<NamespaceName> const& namespace_,
                 UnqualifiedSymbol const& symbol,
                 std::vector<Location> const& locations) throw(){
    addSymbol(namespace_,symbol,locations,{});
  }
  void addSymbol(std::vector<NamespaceName> const& namespace_,
                 UnqualifiedSymbol const& symbol,
                 std::vector<Header> const& headers) throw(){
    addSymbol(namespace_,symbol,{},headers);
  }
  
                 
  class UnknownNamespace : public xju::Exception
  {
  public:
    using xju::Exception::Exception;
  };
  class UnknownSymbol : public xju::Exception
  {
  public:
    using xju::Exception::Exception;
  };

  // Lookup namespace_::symbol when it is referenced
  // from scope fromScope_.
  //
  // eg to lookup X in
  //    namespace a { b::c::X f(); }
  // lookup( {'a'}, {'b','c'}, X) assuming *this is the root namespace
  FoundIn lookup(std::vector<NamespaceName> const& fromScope,
                 std::vector<NamespaceName> const& namespace_,
                 UnqualifiedSymbol const& symbol) const /*throw(
                   UnknownNamespace,
                   UnknownSymbol)*/
  {
    try {
      return lookup_( std::make_pair(fromScope.begin(),fromScope.end()),
                      namespace_,
                      symbol);
    }
    catch(xju::Exception& e) {
      std::ostringstream s;
      s << "lookup locations of "
        << xju::format::join(namespace_.begin(),namespace_.end(),"::")
        << "::" << symbol
        << " when it is referenced from "
        << xju::format::join(fromScope.begin(),fromScope.end(),"::") << "::";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
      
        
private:
  typedef std::vector<Location> Locations;
  typedef std::vector<Header> Headers;
  
  std::map<NamespaceName, Namespace> children_;
  std::map<UnqualifiedSymbol, FoundIn> symbols_;

  // implementation of lookup above
  FoundIn lookup_(
    std::pair<std::vector<NamespaceName>::const_iterator,
              std::vector<NamespaceName>::const_iterator> const& fromScope,
                               std::vector<NamespaceName> const& namespace_,
                               UnqualifiedSymbol const& symbol) const /*throw(
                                 UnknownNamespace,
                                 UnknownSymbol)*/
  {
    if (fromScope.first!=fromScope.second) {
      auto const i=children_.find(*fromScope.first);
      if (i != children_.end()) {
        try {
          return (*i).second.lookup_(
            std::make_pair(xju::next(fromScope.first),fromScope.second),
            namespace_,
            symbol);
        }
        catch(UnknownSymbol const&) {
        }
        catch(UnknownNamespace const&) {
        }
      }
    }
    return findNamespace(
      std::make_pair(namespace_.begin(),namespace_.end())).findSymbol(
        symbol);
  }
  
    
  // find namespace given by path within this namespace, adding children where
  // necessary
  // post: path.size() || result===root
  Namespace& findNamespace(
    std::pair<std::vector<NamespaceName>::const_iterator,
              std::vector<NamespaceName>::const_iterator> const& path) throw()
  {
    if (path.first==path.second) {
      return *this;
    }
    auto i=children_.find(*path.first);
    if (i==children_.end()) {
      i=children_.insert( {*path.first,Namespace()} ).first;
    }
    return (*i).second.findNamespace( {xju::next(path.first),path.second} );
  }

  // find namespace given by path within *this
  // post: path.size() || result===*this
  Namespace const& findNamespace(
    std::pair<std::vector<NamespaceName>::const_iterator,
              std::vector<NamespaceName>::const_iterator> const& path) const
    /*throw(UnknownNamespace)*/
  {
    try {
      if (path.first==path.second) {
        return *this;
      }
      auto i=children_.find(*path.first);
      if (i==children_.end()) {
        std::vector<NamespaceName> known;
        for(auto x:children_) {
          known.push_back(x.first);
        }
        std::ostringstream s;
        s << "unknown namespace " << (*path.first)
          << ", not one of "
          << xju::format::join(known.begin(),known.end(),",");
        throw UnknownNamespace(s.str(),XJU_TRACED);
      }
      return (*i).second.findNamespace({xju::next(path.first),path.second});
    }
    catch(xju::Exception& e) {
      std::ostringstream s;
      s << "find namespace " << xju::format::join(path.first,path.second,"::");
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
  
  FoundIn const& findSymbol(
    UnqualifiedSymbol const& symbol) const /*throw(
      UnknownSymbol)*/
  {
    try {
      auto i=symbols_.find(symbol);
      if (i==symbols_.end()) {
        throw UnknownSymbol("unknown symbol",XJU_TRACED);
      }
      return (*i).second;
    }
    catch(xju::Exception& e) {
      std::vector<UnqualifiedSymbol> known;
      for(auto x:symbols_) {
        known.push_back(x.first);
      }
      std::ostringstream s;
      s << "find symbol " << symbol << " amongst "
        << xju::format::join(known.begin(),known.end(),",");
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }

};

}
}
