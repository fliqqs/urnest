// Copyright (c) 2017 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <hcp/tags/Lookup.hh>

#include <hcp/tags/str.hh> //impl
#include <iostream> //impl
#include <xju/io.hh>
#include <xju/pipe.h> //impl
#include <xju/now.h> //impl
#include <memory>
#include <vector>
#include <map>
#include <utility>
#include <xju/path.hh>
#include <atomic>
#include "xju/io/FileObserver.hh"

namespace hcp
{
namespace tags
{
class TagLookupService : Lookup
{
public:
  // create tags lookup service covering tagsFiles
  // - tagsFiles need not exist yet, but their parent directories must exist
  explicit TagLookupService(
    std::set<std::pair<xju::path::AbsolutePath,xju::path::FileName> > const& tagsFiles) throw(
      // eg a parent directory does not exist
      xju::Exception):
      stop_(false),
      filesWatcher_(tagsFiles),
      files_(makeFiles(tagsFiles)),
      stopper_(xju::pipe())
  {
  }

  // track tags file changes, until stop() called
  // - note that files should be updated by writing to a separate file
  //   then renaming over the tagsFile
  //
  void run() throw()
  {
    std::set<xju::io::Input const*> const inputs(
      {&filesWatcher_,&*stopper_.second});
    while(!stop_.load()) {
      if (xju::io::select(inputs,xju::now()+std::chrono::seconds(10))
          .find(&filesWatcher_)!=inputs.end()) {
        updateFiles();
      }
    }
  }

  // make current and future calls to run() return immediately
  void stop() throw()
  {
    stop_.store(true);
    stopper_.second->write("x",1U,std::chrono::system_clock::now());
  }

  // lookup symbol amongst tags files
  // - returns results from a tags file that knows about symbol
  //
  Locations lookupSymbol(NamespaceNames const& fromScope,
                         NamespaceNames const& symbolScope,
                         UnqualifiedSymbol const& symbol) throw() {
    for(x:files_) {
      auto const l(x.second->lookupSymbol(fromScope,symbolScope,symbol));
      if (l.size()) {
        std::cerr << "found " << str(symbolScope) << str(symbol)
                  << " (referenced from ::"
                  << str(fromScope)
                  << ") in tags file "
                  << xju::path::str(x.first);
        return l;
      }
    }
    return Locations();
  }

  // update ie reload any files that have changed
  void updateFiles() throw()
  {
    for(auto x: filesWatcher_.read(xju::now())) {
      std::ostringstream s;
      s << "reload tags file " << str(x);
      try {
        std::cout << s.str() << std::endl;
        files_[x]->reload();
      }
      catch(xju::Exception& e) {
        e.addContext(s.str(),XJU_TRACED);
        std::cerr << "ERROR: " << readable(e) << std::endl;
      }
    }
  }
  
private:
  typedef std::pair<xju::path::AbsolutePath,xju::path::FileName> AbsFile;

  std::atomic<bool> stop_;
  xju::io::FileObserver filesWatcher_;
  std::map<AbsFile, std::unique_ptr<TagsFile> > files_;

  std::pair<std::unique_ptr<xju::io::IStream>,
            std::unique_ptr<xju::io::OStream> > const stopper_;

  static std::map<AbsFile, std::unique_ptr<TagsFile> > makeFiles(
    std::set<AbsFile> const& tagsFiles) throw()
  {
    std::map<AbsFile, std::unique_ptr<TagsFile> > result;
    std::transform(tagsFiles.begin(),
                   tagsFiles.end(),
                   std::inserter(result,result.end()),
                   [](AbsFile const& f) {
                     return std::make_pair(
                       f,
                       std::unique_ptr<TagsFile>(
                         new TagsFile(f.first,f.second)));
                   });
  }
                     
};
  
}
}
