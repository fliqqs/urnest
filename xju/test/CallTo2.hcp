//generated by xju/test/CallToPn.py

#include <xju/test/CallTo.hh>

namespace xju
{
namespace test
{

template<class T,class U,class P1,class P2>
class CallToV2 : public CallToVoid
{
public:
  explicit CallToV2(
    T& x,
    void (U::*f)(P1,P2),
    P1 const& p1,
    P2 const& p2)
      : x_(x),
        f_(f),
        p1_(p1),
        p2_(p2)
  {
  }
  T& x_;
  void (U::* const f_)(P1,P2);
  P1 p1_;
  P2 p2_;
};

template<class T,class U,class P1,class P2>
class CallToV2_ : public CallToVoid
{
public:
  explicit CallToV2_(
    T& x,
    void (U::*f)(P1,P2))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(P1,P2);

  std::shared_ptr<CallToV2<T,U, P1, P2> > operator()(
    P1 p1,
    P2 p2){
    return std::shared_ptr<CallToV2<T,U, P1, P2> >(
      new CallToV2<T,U, P1, P2>(x_, f_, p1, p2));
  }
};

template<class T,class U,class P1,class P2>
CallToV2_<T,U, P1, P2> callTo(
    T& x,
    void (U::*f)(P1,P2))
{
  return CallToV2_<T,U, P1, P2>(x,f);
}

template<class T,class U,class R,class P1,class P2>
class CallToR2 : public CallToR<R>
{
public:
  explicit CallToR2(
    T& x,
    R (U::*f)(P1,P2),
    P1 const& p1,
    P2 const& p2)
      : x_(x),
        f_(f),
        p1_(p1),
        p2_(p2)
  {
  }
  T& x_;
  R (U::* const f_)(P1,P2);
  P1 p1_;
  P2 p2_;

};

template<class T,class U,class R,class P1,class P2>
class CallToR2_ : public CallToR<R>
{
public:
  explicit CallToR2_(
    T& x,
    R (U::*f)(P1,P2))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(P1,P2);

  std::shared_ptr<CallToR2<T,U,R, P1, P2> > operator()(
    P1 p1,
    P2 p2){
    return std::shared_ptr<CallToR2<T,U,R, P1, P2> >(
      new CallToR2<T,U,R, P1, P2>(x_, f_, p1, p2));
  }
};

template<class T,class U,class R,class P1,class P2>
CallToR2_<T,U,R, P1, P2> callTo(
    T& x, 
    R (U::*f)(P1,P2))
{
  return CallToR2_<T,U,R, P1, P2>(x,f);
}


template<class T,class U,class P1,class P2>
class CallToVc2 : public CallToVoid
{
public:
  explicit CallToVc2(
    T& x,
    void (U::*f)(P1,P2) const ,
    P1 const& p1,
    P2 const& p2)
      : x_(x),
        f_(f),
        p1_(p1),
        p2_(p2)
  {
  }
  T& x_;
  void (U::* const f_)(P1,P2) const;
  P1 p1_;
  P2 p2_;
};

template<class T,class U,class P1,class P2>
class CallToVc2_ : public CallToVoid
{
public:
  explicit CallToVc2_(
    T& x,
    void (U::*f)(P1,P2) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(P1,P2) const;

  std::shared_ptr<CallToVc2<T,U, P1, P2> > operator()(
    P1 p1,
    P2 p2){
    return std::shared_ptr<CallToVc2<T,U, P1, P2> >(
      new CallToVc2<T,U, P1, P2>(x_, f_, p1, p2));
  }
};

template<class T,class U,class P1,class P2>
CallToVc2_<T,U, P1, P2> callTo(
    T& x,
    void (U::*f)(P1,P2) const)
{
  return CallToVc2_<T,U, P1, P2>(x,f);
}

template<class T,class U,class R,class P1,class P2>
class CallToRc2 : public CallToR<R>
{
public:
  explicit CallToRc2(
    T& x,
    R (U::*f)(P1,P2) const ,
    P1 const& p1,
    P2 const& p2)
      : x_(x),
        f_(f),
        p1_(p1),
        p2_(p2)
  {
  }
  T& x_;
  R (U::* const f_)(P1,P2) const;
  P1 p1_;
  P2 p2_;

};

template<class T,class U,class R,class P1,class P2>
class CallToRc2_ : public CallToR<R>
{
public:
  explicit CallToRc2_(
    T& x,
    R (U::*f)(P1,P2) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(P1,P2) const;

  std::shared_ptr<CallToRc2<T,U,R, P1, P2> > operator()(
    P1 p1,
    P2 p2){
    return std::shared_ptr<CallToRc2<T,U,R, P1, P2> >(
      new CallToRc2<T,U,R, P1, P2>(x_, f_, p1, p2));
  }
};

template<class T,class U,class R,class P1,class P2>
CallToRc2_<T,U,R, P1, P2> callTo(
    T& x, 
    R (U::*f)(P1,P2) const)
{
  return CallToRc2_<T,U,R, P1, P2>(x,f);
}


}
}

