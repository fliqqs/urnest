#!/bin/env python
# coding: utf-8
#
# Copyright (c) 2018 Trevor Taylor
# 
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that all
# copyright notices and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

import sys

template='''\
//generated by xju/test/CallToPn.py

#include <xju/test/CallTo.hh>

namespace xju
{
namespace test
{

template<class T,class U`pClasses`>
class CallToV`nParams` : public CallToVoid
{
public:
  explicit CallToV`nParams`(
    T& x,
    void (U::*f)(`fParams`)`params`)
      : x_(x),
        f_(f)`paramInits`
  {
  }
  T& x_;
  void (U::* const f_)(`fParams`);`paramMembers`
};

template<class T,class U`pClasses`>
class CallToV`nParams`_ : public CallToVoid
{
public:
  explicit CallToV`nParams`_(
    T& x,
    void (U::*f)(`fParams`))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(`fParams`);

  std::shared_ptr<CallToV`nParams`<T,U`pTypes`> > operator()(`params2`){
    return std::shared_ptr<CallToV`nParams`<T,U`pTypes`> >(
      new CallToV`nParams`<T,U`pTypes`>(x_, f_`paramNames`));
  }
};

template<class T,class U`pClasses`>
CallToV`nParams`_<T,U`pTypes`> callTo(
    T& x,
    void (U::*f)(`fParams`))
{
  return CallToV`nParams`_<T,U`pTypes`>(x,f);
}

template<class T,class U,class R`pClasses`>
class CallToR`nParams` : public CallToR<R>
{
public:
  explicit CallToR`nParams`(
    T& x,
    R (U::*f)(`fParams`)`params`)
      : x_(x),
        f_(f)`paramInits`
  {
  }
  T& x_;
  R (U::* const f_)(`fParams`);`paramMembers`

};

template<class T,class U,class R`pClasses`>
class CallToR`nParams`_ : public CallToR<R>
{
public:
  explicit CallToR`nParams`_(
    T& x,
    R (U::*f)(`fParams`))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(`fParams`);

  std::shared_ptr<CallToR`nParams`<T,U,R`pTypes`> > operator()(`params2`){
    return std::shared_ptr<CallToR`nParams`<T,U,R`pTypes`> >(
      new CallToR`nParams`<T,U,R`pTypes`>(x_, f_`paramNames`));
  }
};

template<class T,class U,class R`pClasses`>
CallToR`nParams`_<T,U,R`pTypes`> callTo(
    T& x, 
    R (U::*f)(`fParams`))
{
  return CallToR`nParams`_<T,U,R`pTypes`>(x,f);
}


template<class T,class U`pClasses`>
class CallToVc`nParams` : public CallToVoid
{
public:
  explicit CallToVc`nParams`(
    T& x,
    void (U::*f)(`fParams`) const `params`)
      : x_(x),
        f_(f)`paramInits`
  {
  }
  T& x_;
  void (U::* const f_)(`fParams`) const;`paramMembers`
};

template<class T,class U`pClasses`>
class CallToVc`nParams`_ : public CallToVoid
{
public:
  explicit CallToVc`nParams`_(
    T& x,
    void (U::*f)(`fParams`) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(`fParams`) const;

  std::shared_ptr<CallToVc`nParams`<T,U`pTypes`> > operator()(`params2`){
    return std::shared_ptr<CallToVc`nParams`<T,U`pTypes`> >(
      new CallToVc`nParams`<T,U`pTypes`>(x_, f_`paramNames`));
  }
};

template<class T,class U`pClasses`>
CallToVc`nParams`_<T,U`pTypes`> callTo(
    T& x,
    void (U::*f)(`fParams`) const)
{
  return CallToVc`nParams`_<T,U`pTypes`>(x,f);
}

template<class T,class U,class R`pClasses`>
class CallToRc`nParams` : public CallToR<R>
{
public:
  explicit CallToRc`nParams`(
    T& x,
    R (U::*f)(`fParams`) const `params`)
      : x_(x),
        f_(f)`paramInits`
  {
  }
  T& x_;
  R (U::* const f_)(`fParams`) const;`paramMembers`

};

template<class T,class U,class R`pClasses`>
class CallToRc`nParams`_ : public CallToR<R>
{
public:
  explicit CallToRc`nParams`_(
    T& x,
    R (U::*f)(`fParams`) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(`fParams`) const;

  std::shared_ptr<CallToRc`nParams`<T,U,R`pTypes`> > operator()(`params2`){
    return std::shared_ptr<CallToRc`nParams`<T,U,R`pTypes`> >(
      new CallToRc`nParams`<T,U,R`pTypes`>(x_, f_`paramNames`));
  }
};

template<class T,class U,class R`pClasses`>
CallToRc`nParams`_<T,U,R`pTypes`> callTo(
    T& x, 
    R (U::*f)(`fParams`) const)
{
  return CallToRc`nParams`_<T,U,R`pTypes`>(x,f);
}


}
}
'''

def expandTemplate(t, vars):
    '''expand `X` in t with vars['X']'''
    rest=t
    result=''
    while '`' in rest:
        before,name,rest=rest.split('`',2)
        result=result+before+str(vars[name])
        pass
    result=result+rest
    return result

nParams=int(sys.argv[1])
pClasses=''.join([f',class P{n}'
                  for n in range(1,nParams+1)])
pTypes=''.join([f', P{n}'
                  for n in range(1,nParams+1)])
fParams=','.join([f'P{n}'
                  for n in range(1,nParams+1)])
params=  ''.join([f',\n    P{n} const& p{n}'
                  for n in range(1,nParams+1)])
params2=  ','.join([f'\n    P{n} p{n}'
                  for n in range(1,nParams+1)])
paramInits=''.join([f',\n        p{n}_(p{n})'
                    for n in range(1,nParams+1)])
paramMembers=''.join([f'\n  P{n} p{n}_;'
                      for n in range(1,nParams+1)])
paramNames=''.join([f', p{n}'
                    for n in range(1,nParams+1)])

print(expandTemplate(template,vars()))
