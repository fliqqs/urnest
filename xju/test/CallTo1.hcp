//generated by xju/test/CallToPn.py

#include <xju/test/CallTo.hh>

namespace xju
{
namespace test
{

template<class T,class U,class P1>
class CallToV1 : public CallToVoid
{
public:
  explicit CallToV1(
    T& x,
    void (U::*f)(P1),
    P1 const& p1)
      : x_(x),
        f_(f),
        p1_(p1)
  {
  }
  T& x_;
  void (U::* const f_)(P1);
  P1 p1_;
};

template<class T,class U,class P1>
class CallToV1_ : public CallToVoid
{
public:
  explicit CallToV1_(
    T& x,
    void (U::*f)(P1))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(P1);

  std::shared_ptr<CallToV1<T,U, P1> > operator()(
    P1 p1){
    return std::shared_ptr<CallToV1<T,U, P1> >(
      new CallToV1<T,U, P1>(x_, f_, p1));
  }
};

template<class T,class U,class P1>
CallToV1_<T,U, P1> callTo(
    T& x,
    void (U::*f)(P1))
{
  return CallToV1_<T,U, P1>(x,f);
}

template<class T,class U,class R,class P1>
class CallToR1 : public CallToR<R>
{
public:
  explicit CallToR1(
    T& x,
    R (U::*f)(P1),
    P1 const& p1)
      : x_(x),
        f_(f),
        p1_(p1)
  {
  }
  T& x_;
  R (U::* const f_)(P1);
  P1 p1_;

};

template<class T,class U,class R,class P1>
class CallToR1_ : public CallToR<R>
{
public:
  explicit CallToR1_(
    T& x,
    R (U::*f)(P1))
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(P1);

  std::shared_ptr<CallToR1<T,U,R, P1> > operator()(
    P1 p1){
    return std::shared_ptr<CallToR1<T,U,R, P1> >(
      new CallToR1<T,U,R, P1>(x_, f_, p1));
  }
};

template<class T,class U,class R,class P1>
CallToR1_<T,U,R, P1> callTo(
    T& x, 
    R (U::*f)(P1))
{
  return CallToR1_<T,U,R, P1>(x,f);
}


template<class T,class U,class P1>
class CallToVc1 : public CallToVoid
{
public:
  explicit CallToVc1(
    T& x,
    void (U::*f)(P1) const ,
    P1 const& p1)
      : x_(x),
        f_(f),
        p1_(p1)
  {
  }
  T& x_;
  void (U::* const f_)(P1) const;
  P1 p1_;
};

template<class T,class U,class P1>
class CallToVc1_ : public CallToVoid
{
public:
  explicit CallToVc1_(
    T& x,
    void (U::*f)(P1) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  void (U::* const f_)(P1) const;

  std::shared_ptr<CallToVc1<T,U, P1> > operator()(
    P1 p1){
    return std::shared_ptr<CallToVc1<T,U, P1> >(
      new CallToVc1<T,U, P1>(x_, f_, p1));
  }
};

template<class T,class U,class P1>
CallToVc1_<T,U, P1> callTo(
    T& x,
    void (U::*f)(P1) const)
{
  return CallToVc1_<T,U, P1>(x,f);
}

template<class T,class U,class R,class P1>
class CallToRc1 : public CallToR<R>
{
public:
  explicit CallToRc1(
    T& x,
    R (U::*f)(P1) const ,
    P1 const& p1)
      : x_(x),
        f_(f),
        p1_(p1)
  {
  }
  T& x_;
  R (U::* const f_)(P1) const;
  P1 p1_;

};

template<class T,class U,class R,class P1>
class CallToRc1_ : public CallToR<R>
{
public:
  explicit CallToRc1_(
    T& x,
    R (U::*f)(P1) const)
      : x_(x),
        f_(f)
  {
  }
  T& x_;
  R (U::* const f_)(P1) const;

  std::shared_ptr<CallToRc1<T,U,R, P1> > operator()(
    P1 p1){
    return std::shared_ptr<CallToRc1<T,U,R, P1> >(
      new CallToRc1<T,U,R, P1>(x_, f_, p1));
  }
};

template<class T,class U,class R,class P1>
CallToRc1_<T,U,R, P1> callTo(
    T& x, 
    R (U::*f)(P1) const)
{
  return CallToRc1_<T,U,R, P1>(x,f);
}


}
}

