// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <string>
#include <sstream> //impl
#include <xju/format.hh> //impl
#include <hcp/ast.hh>
#include <hcp/parser.hh>
#include <xju/Tagged.hh>
#include <xju/Utf8String.hh>
#include <xju/readThrough.hh> //impl
#include <xju/startsWith.hh> //impl
#include <iostream>
#include <xju/iosthrow.hh> //impl

namespace xju
{
namespace ssh
{
namespace transport
{

char const identificationLeader[]="SSH-2.0-";

class SSHVersionTag{};
typedef xju::Tagged<std::string,SSHVersionTag> SSHVersion;
typedef hcp_ast::TaggedItem<SSHVersionTag> SSHVersionItem;
class SoftwareVersionTag{};
typedef xju::Tagged<std::string,SoftwareVersionTag> SoftwareVersion;
typedef hcp_ast::TaggedItem<SoftwareVersionTag> SoftwareVersionItem;
class IdentCommentTag{};
typedef hcp_ast::TaggedItem<IdentCommentTag> IdentCommentItem;

hcp_parser::PR identParser() noexcept
{
  using namespace hcp_parser;
  PR identChars(!parseOneOfChars(" -")+usAsciiPrintable());
  PR nullChar(charInRange(0,0));
  PR SP(parseLiteral(" "));
  static PR result(
    "SSH-"+named<SSHVersionItem>("SSH version",parseUntil(identChars,"-"))+
    "-"+named<SoftwareVersionItem>("software version",
                                   parseUntil(identChars,crlf|SP))+
    (named<IdentCommentItem>("comment",!SP)| //no comment
     (SP+named<IdentCommentItem>("comment",parseUntil(!nullChar+parseAnyChar(),
                                                      crlf))))+
    crlf);
  return result;
}


//pre: softwareVersion valid per rfc4253 'softwareversion' ie
//     US-ASCII printable excluding whitespace and minus
//pre: comments contains no \r, \n or null characters
void writeIdentificationString(
  std::ostream& s,
  SoftwareVersion const& softwareVersion,
  std::string const& comments)
// std::bad_alloc
// xju::Exception - e.g. stream write failed
{
  try
  {
    xju::iosthrow x(s);
    try{
      s << identificationLeader << softwareVersion;
      if (comments.size()){
        s << " " << comments;
      }
      s << "\r\n";
    }
    catch(std::bad_alloc const&)
    {
      throw;
    }
    catch(xju::Exception& e){
      throw;
    }
    catch(std::exception const& e){
      throw xju::Exception(e.what(),XJU_TRACED);
    }
  }
  catch(xju::Exception& e){
    std::ostringstream si;
    writeIdentificationString(si,softwareVersion,comments);
    std::ostringstream s;
    s << "write SSH identification string "
      << xju::format::quote(xju::format::cEscapeString(si.str()));
    e.addContext(s.str(),XJU_TRACED);
    throw;
  }
}

std::tuple<
  std::vector<std::string>, //preamble lines without trailing \r\n
  SSHVersion, //ssh version
  SoftwareVersion, //software version
  std::string //comment
  > readIdentificationString(std::istream& s)
// std::bad_alloc
// xju::Exception - e.g. stream read failed
{
  std::vector<std::string> preamble;
  try{
    xju::iosthrow x(s);
    try{
      std::string x;
      for(x=xju::readThrough(s,"\r\n",255); //255 from rfc4253
          !xju::startsWith(x,std::string("SSH-"));
          x=xju::readThrough(s,"\r\n",255))
      {
        preamble.push_back(std::string(x.begin(),x.end()-2));
      }
      auto const y(hcp_parser::parseString(x.begin(),x.end(),identParser()));
      SSHVersion sshVersion(
        hcp_ast::reconstruct(
          hcp_ast::findOnlyChildOfType<SSHVersionItem>(y)));
      SoftwareVersion softwareVersion(
        hcp_ast::reconstruct(
          hcp_ast::findOnlyChildOfType<SoftwareVersionItem>(y)));
      std::string comment(
        hcp_ast::reconstruct(
          hcp_ast::findOnlyChildOfType<IdentCommentItem>(y)));
      return std::make_tuple(preamble,
                             sshVersion,
                             softwareVersion,
                             comment);
    }
    catch(std::bad_alloc const&)
    {
      throw;
    }
    catch(xju::Exception& e){
      throw;
    }
    catch(std::exception const& e){
      throw xju::Exception(e.what(),XJU_TRACED);
    }
  }
  catch(xju::Exception& e){
    std::ostringstream s;
    s << "read SSH identification string from istream having read "
      << preamble.size() << " preamble lines: "
      << xju::format::join(preamble.begin(),
                           preamble.end(),
                           [](auto const& x){
                             return xju::format::quote(
                               xju::format::cEscapeString(x));
                           },
                           ", ");

    e.addContext(s.str(),XJU_TRACED);
    throw;
  }
}

}

}
}
