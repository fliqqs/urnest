// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <xju/ssh/transport/I.hh>
#include <xju/ssh/transport/O.hh>
#include <xju/ssh/transport/Algorithms.hh>
#include <xju/ssh/transport/Ident.hh>
#include <utility>
#include <vector>
#include <string>
#include <xju/Lock.hh> //impl
#include <xju/assert.hh> //impl
#include <memory> //impl
#include <xju/DeadlineReached.hh> //impl
#include <xju/steadyNow.hh> //impl
#include <xju/Mutex.hh>
#include <xju/Condition.hh>
#include <memory>
#include <xju/ssh/transport/SessionId.hh>
#include <sstream> //impl
#include <xju/format.hh> //impl
#include <xju/Exception.hh> //impl
#include <optional> //impl
#include <xju/ssh/transport/makeKexInitRequest.hh> //impl
#include <xju/ssh/transport/chooseKexer.hh> //impl
#include <xju/ssh/transport/chooseHostKeyAlgorithm.hh> //impl

namespace xju
{
namespace ssh
{
namespace transport
{

class Rekeyer
{
public:
  // performs initial key exchange
  // pre: i, o, algorithms will outlive this
  Rekeyer(I& i, O& o, Algorithms const& algorithms,
          Ident ourIdent,
          std::pair<std::vector<std::string>,Ident> peerPreambleAndIdent):
      ourIdent_(std::move(ourIdent)),
      peerPreambleAndIdent_(std::move(peerPreambleAndIdent)),
      o_(o),
      i_(i),
      algorithms_(algorithms),
      changed_(guard_),
      sessionId_(doInitialKex())
  {
  }
  Ident const ourIdent_;
  std::pair<std::vector<std::string>,Ident> const peerPreambleAndIdent_;
  
  // commences rekeying
  void startRekeying()
  {
    xju::Lock l(guard_);
    xju::assert_equal(ol_.get(),false);
    ol_=std::unique_ptr<O::RekeyLock>(
      new O::RekeyLock(o_,makeKexInitRequest(algorithms_)));
  }

  // pre: calling thread has caught I::Rekeying
  void finishRekeying()
  // Message - in transit message received - call again
  {
    xju::Lock l(guard_);
    if (ol_.get()){
      // since this method always runs to completion in the case
      // of peer-initiated rekey, this must be a local-initiated rekey
      // (via startRekeying above) and we cannot have recieved
      // peer KexInit yet
      changed_.signal(l);
      I::RekeyLock il(i_);
      auto ol(std::move(ol_));
      doKex(l,il,*ol,sessionId_);
    }
    else{
      // Not local, so must be peer-initiated and when we receive
      // the peer KexInit we always finish rekey before returning.
      // Note that even though there is a window where a receiver
      // thread can catch a Rekeying but another thread could finish
      // that rekeying before the first thread calls finishRekeying, it
      // won't happen because no other thread will call rekeying (only
      // one receive thread + one transmit thread allowed, and only the
      // receive thread is allowed to call finishRekeying).
      changed_.signal(l);
      I::RekeyLock il(i_);
      O::RekeyLock ol(o_,makeKexInitRequest(algorithms_));
      doKex(l,il,ol,sessionId_);
    }
  }
  
  void waitTillRekeyed(std::chrono::steady_clock::time_point const& deadline)
  {
    xju::Lock l(guard_);
    //REVISIT: what if fail during rekeying?
    while(ol_.get())
    {
      if (xju::steadyNow()>deadline){
        throw xju::DeadlineReached(xju::Exception("deadline reached",XJU_TRACED));
      }
      changed_.wait(l,deadline);
    }
  }
  
private:
  I& i_;
  O& o_;
  Algorithms const& algorithms_;
  
  xju::Mutex guard_;
  xju::Condition changed_;
  std::unique_ptr<O::RekeyLock> ol_;

public:
  SessionId const sessionId_;
  
private:
  //REVISIT: make this a free function
  SessionId doKex(xju::Lock const& l,
                  I::RekeyLock& il,
                  O::RekeyLock& ol,
                  std::optional<SessionId> const& sessionId)
  {
    xju::assert_equal(l.holds(guard_),true);
    
    auto const clientKexInit(algorithms_.chooseClientKexInit(
                               ol.sent_,
                               il.peerKexInit_));
    auto const serverKexInit(algorithms_.chooseServerKexInit(
                               ol.sent_,
                               il.peerKexInit_));
    std::set<HostKeyAlgorithmName> const clientRequestedHostKeyAlgorithmNames(
      clientKexInit.serverHostKeyAlgorithmNames_.begin(),
      clientKexInit.serverHostKeyAlgorithmNames_.end());
    std::set<HostKeyAlgorithmName> const serverProposedHostKeyAlgorithmNames(
      serverKexInit.serverHostKeyAlgorithmNames_.begin(),
      serverKexInit.serverHostKeyAlgorithmNames_.end());
    
    auto kexer=chooseKexer(
      clientKexInit.kexAlgorithms_,
      serverKexInit.kexAlgorithms_,
      clientRequestedHostKeyAlgorithmNames,
      serverProposedHostKeyAlgorithmNames,
      std::map<KexAlgorithmName,std::reference_wrapper<Kexer> >(
        algorithms_.kexers_.begin(),
        algorithms_.kexers_.end()),
      std::map<HostKeyAlgorithmName,std::reference_wrapper<HostKeyAlgorithm> >(
        algorithms_.hostKeyers_.begin(),
        algorithms_.hostKeyers_.end()));
    
    std::pair<K,H> kh(
      kexer.first.get().exchangeKeys(
        il,ol,
        ourIdent_,
        peerPreambleAndIdent_,
        clientKexInit,
        serverKexInit,
        chooseHostKeyAlgorithm(
          clientKexInit.serverHostKeyAlgorithmNames_,
          std::set<HostKeyAlgorithmName>(
            serverKexInit.serverHostKeyAlgorithmNames_.begin(),
            serverKexInit.serverHostKeyAlgorithmNames_.end()),
          kexer.first.get().requiresEncryptionCapableHostKey(),
          kexer.first.get().requiresSignatureCapableHostKey(),
          std::map<HostKeyAlgorithmName,
                   std::reference_wrapper<HostKeyAlgorithm> >(
            algorithms_.hostKeyers_.begin(),
            algorithms_.hostKeyers_.end())),
        il.peerKexInit_.firstKexPacketFollows_&&!kexer.second));

    SessionId result(sessionId.has_value()?sessionId.value():
                     SessionId(kh.second.value()));
    auto const& k(kh.first);
    auto const& h(kh.second);
    
    auto& decryptionCipherAlgorithm(
      algorithms_.chooseDecryptionCipher(ol.sent_,il.peerKexInit_));
    il.setDecrypter(
      decryptionCipherAlgorithm.decrypter(
        CipherKey(
          resizeHash(
            kexer.first.get().hash(
              algorithms_.decryptionCipherKeyData(k,h,result)),
            decryptionCipherAlgorithm.keySize_,
            k,h,kexer)),
        CipherIV(
          resizeHash(
            kexer.first.get().hash(
              algorithms_.decryptionCipherIVData(k,h,result)),
            decryptionCipherAlgorithm.ivSize_,
            k,h,kexer))));

    auto& encryptionCipherAlgorithm(
      algorithms_.chooseEncryptionCipher(ol.sent_,il.peerKexInit_));
    ol.setEncrypter(
      encryptionCipherAlgorithm.encrypter(
        CipherKey(
          resizeHash(
            kexer.first.get().hash(
              algorithms_.encryptionCipherKeyData(k,h,result)),
            encryptionCipherAlgorithm.keySize_,
            k,h,kexer)),
        CipherIV(
          resizeHash(
            kexer.first.get().hash(
              algorithms_.encryptionCipherIVData(k,h,result)),
            encryptionCipherAlgorithm.ivSize_,
            k,h,kexer))));

    auto& macVerifierAlgorithm(algorithms_.chooseMacVerifierAlgorithm());
    il.setMacVerifier(
      algorithms_.chooseMacVerifierAlgorithm().macVerifier(
        xju::crypt::MacKey(
          resizeHash(
            kexer.first.get().hash(algorithms_.macVerifierKeyData(k,h,result)),
            macVerifierAlgorithm.keySize_,
            k,h,kexer))));

    auto& macCalculatorAlgorithm(algorithms_.chooseMacCalculatorAlgorithm());
    ol.setMacCalculator(
      macCalculatorAlgorithm.macCalculator(
        xju::crypt::MacKey(
          resizeHash(
            kexer.first.get().hash(
              algorithms_.macCalculatorKeyData(k,h,result)),
            macCalculatorAlgorithm.keySize_,
            k,h,kexer))));
    
    return result;
  }

  SessionId doInitialKex()
  {
    xju::Lock l(guard_);
    O::RekeyLock ol(o_,makeKexInitRequest(algorithms_));
    try{
      auto m(i_.receiveMessage(REVISIT));
      std::ostringstream s;
      s << "expected KexInit (type "
        << xju::format::hex((char)MSG::KEXINIT)<< ") message, received " << m;
      throw xju::Exception(s.str(),XJU_TRACED);
    }
    catch(I::Rekeying const&){
      I::RekeyLock il(i_);
      return doKex(l,il,ol,std::optional<SessionId>());
    }
  }
};

}
}
}
