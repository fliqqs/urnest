// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <xju/ssh/transport/Algorithms.hh>
#include <xju/io/IBuf.hh>
#include <xju/io/OBuf.hh>
#include <utility>
#include <vector>
#include <xju/ssh/transport/Ident.hh>
#include <xju/ssh/transport/I.hh>
#include <xju/ssh/transport/O.hh>
#include <xju/ssh/transport/Rekeyer.hh>
#include <xju/io/IStream.hh>
#include <xju/io/OStream.hh>
#include <unistd.h>
#include <xju/ssh/transport/ClientAlgorithms.hh>
#include <chrono>
#include <xju/ssh/transport/shakeHands.hh> //impl
#include <xju/Exception.hh>
#include <xju/ssh/transport/Message.hh>
#include <sstream> //impl
#include <xju/ssh/transport/PacketAuthenticationAlgorithm.hh> //impl
#include <xju/ssh/transport/CipherAlgorithm.hh> //impl
#include <xju/ssh/transport/ciphers/None.hh> //impl
#include <xju/ssh/transport/macs/None.hh> //impl
#include <iostream>

namespace xju
{
namespace ssh
{
namespace transport
{
namespace
{
std::pair<
  std::vector<std::string>, //preamble lines without trailing \r\n
  Ident
> shakeHands_(xju::io::IBuf& ibuf,
              xju::io::OBuf& obuf,
              Ident const& ourIdent)
{
  xju::net::istream i(ibuf);
  xju::net::ostream o(obuf);
  return shakeHands(i,o,ourIdent);
}

}

class Session
{
  xju::io::IStream& is_;
  xju::io::OStream& os_;
  Algorithms const& algorithms_;

  xju::io::IBuf ibuf_;
  xju::io::OBuf obuf_;

  std::pair<std::vector<std::string>,Ident> const peerPreambleAndIdent_;
  
  I i_;
  O o_;

  Rekeyer rekeyer_;

public:
  SessionId const sessionKey_;

  // Establish buffered, secure, host-authenticated SSH client session with 
  // server over i+o by deadline, selecting algorithms from only those
  // specified.
  //
  // Note actual buffer sizes used might be larger than those specified to
  // suit chosen algorithms
  //
  // Note session transparently rekeys as necessary.
  //
  // pre: algorithms, i and o will outlive this
  Session(xju::io::IStream& i,
          xju::io::OStream& o,
          size_t const inputBufferSize,
          size_t const outputBufferSize,
          Ident ourIdent,
          ClientAlgorithms const& algorithms,
          std::chrono::steady_clock::time_point const deadline,
          size_t maxAcceptedKexInitSize):
      is_(i),
      os_(o),
      algorithms_(algorithms),
      obuf_(o,deadline,outputBufferSize),
      ibuf_(i,deadline,inputBufferSize),
      peerPreambleAndIdent_(
        shakeHands_(ibuf_,
                    obuf_,
                    ourIdent)),
      i_(ibuf_,
         std::unique_ptr<Decrypter>(ciphers::None().decrypter(
                                      CipherKey({}),
                                      CipherIV({}))),
         std::unique_ptr<xju::crypt::MacVerifier>(macs::None().macVerifier(
                                                    xju::crypt::MacKey({}))),
         SequenceNumber(0)),
      o_(obuf_,
         std::unique_ptr<Encrypter>(ciphers::None().encrypter(
                                      CipherKey({}),
                                      CipherIV({}))),
         std::unique_ptr<xju::crypt::MacCalculator>(
           macs::None().macCalculator(xju::crypt::MacKey({}))),
         SequenceNumber(0)),
      rekeyer_(i_,
               o_,
               algorithms_,
               ourIdent,
               peerPreambleAndIdent_,
               maxAcceptedKexInitSize),
      sessionKey_(rekeyer_.sessionId_)
  {
  }

  class Closed : public xju::Exception
  {
  public:
    using xju::Exception::Exception;
  };
  
  // Send message by deadline, appending any messages received in the meantime
  // to receivedMessages.
  //
  // This method suits single-threaded clients, which call either
  // sendMessage or receiveMessage according to their application needs.
  //
  // pre: close() has not been called
  //
  void sendMessage(
    Message const& message,
    std::chrono::steady_clock::time_point const& deadline,
    std::back_insert_iterator<std::vector<Message> > receivedMessages)
    // xju::DeadlineReached - message not completely received by deadline
    // Closed - other end has closed
  {
    try{
      xju::io::IBuf::DeadlineOverride ido(ibuf_,deadline);
      xju::io::OBuf::DeadlineOverride odo(obuf_,deadline);

      while(true){
        try{
          o_.sendMessage(message);
          return;
        }
        catch(O::Rekeying const&){
          try{
            rekeyer_.finishRekeying();
          }
          catch(Message& inTransit)
          {
            *receivedMessages++=(std::move(inTransit));
          }
        }
      }
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "send " << message.size() << "-byte message to peer of SSH session "
        << (*this)
        << " by deadline collecting any messages received in the meantime";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
  
  // Send message by deadline.
  //
  // This method is only for multi-threaded clients; receiveMessage must
  // be called concurrently to avoid deadlock due to e.g. rekeying on the fly
  //
  // pre: close() has not been called
  //
  void sendMessage(Message message,
                   std::chrono::steady_clock::time_point const& deadline)
    // xju::DeadlineReached - message not completely received by deadline
    // Closed - other end has closed
  {
    try{
      xju::io::OBuf::DeadlineOverride odo(obuf_,deadline);
      xju::io::IBuf::DeadlineOverride ido(ibuf_,deadline);

      while(true){
        try{
          o_.sendMessage(message);
          return;
        }
        catch(O::Rekeying const&){
          rekeyer_.waitTillRekeyed(deadline);
        }
      }
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "send " << message.size() << "-byte message to peer of SSH session "
        << (*this) << " by deadline";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
  
  // Recieve message by deadline.
  //
  // pre: close() has not been called
  //
  Message receiveMessage(size_t maxSize,
                         std::chrono::steady_clock::time_point const& deadline)
    // xju::DeadlineReached - message not completely received by deadline
    // Closed - other end has closed
  {
    xju::io::OBuf::DeadlineOverride odo(obuf_,deadline);
    xju::io::IBuf::DeadlineOverride ido(ibuf_,deadline);
    while(true){
      try{
        Message m(i_.receiveMessage(maxSize));
        return std::move(m);
      }
      catch(I::Rekeying const&){
        try{
          rekeyer_.finishRekeying();
        }
        catch(Message& inTransit){
          return Message(std::move(inTransit));
        }
      }
    }
  }

  // Notify other end we are done, wait until peer has notified us it
  // is done (noting it might have already).
  // - returns messages received before peer's notification (discarding
  //   further messages once maxResultSize is reached)
  //
  // REVISIT: close has no "ack"?
  //
  // pre: close() has not been called
  //
  // std::vector<Body> close(
  //   std::chrono::steady_clock::time_point const& deadline,
  //   std::size_t maxResultSize)
  // {
  //   //REVISIT
  // }

  friend std::ostream& operator<<(std::ostream& s, Session const& x);
};

std::ostream& operator<<(std::ostream& s, Session const& x)
{
  s << x.is_ << "/" << x.os_;
  return s;
}

}
}
}


