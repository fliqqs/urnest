// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <xju/snmp/decodeSnmpV2cSetRequest.hh>

#include <iostream>
#include <xju/assert.hh>
#include <xju/snmp/NullValue.hh>
#include <xju/snmp/StringValue.hh>
#include <xju/snmp/OidValue.hh>
#include <xju/next.hh>

namespace xju
{
namespace snmp
{
void test1() throw()
{
  // decodeSnmpV2cSetRequest
  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
          });
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
    xju::assert_equal(y.community_,Community("private"));
    xju::assert_equal(y.id_,RequestId(1));
    xju::assert_equal(y.values_.size(),1);
    xju::assert_equal((*y.values_.begin()).first,Oid(".1.3.6.1.4.1.2680.1.2.7.3.2.0"));
    dynamic_cast<NullValue const&>(*(*y.values_.begin()).second);
    xju::assert_equal(r.second,
                      std::vector<Oid>({
                          Oid(".1.3.6.1.4.1.2680.1.2.7.3.2.0")}));
  }
  catch(xju::Exception const& e) {
    xju::assert_not_equal(readableRepr(e),readableRepr(e));
  }
}
void test2() throw()
{
  // decodeSnmpV2cSetRequest failures

  try {
    std::vector<uint8_t> x({
        0x31,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
          });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
    xju::assert_never_reached();
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data because\nexpected sequence type byte 0x30, got 0x31 at offset 0.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes because\nfailed to decode integer at offset 2 because\ntype is 0x03 not 0x02.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x00,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(SnmpVersionMismatch const& e) {
    xju::assert_equal(e.cause().first,"expected snmp version 1 (SNMP V2) but got 0 (SNMP V1)");
  }
  catch(xju::Exception const& e) {
    xju::assert_not_equal(readableRepr(e),readableRepr(e));
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x02,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2 because\nfailed to decode string at offset 5 because\ntype is 0x02 not 0x04.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0xa2,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14 because\nfailed to decode integer at offset 16 because\ntype is 0xa2 not 0x02.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x01,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14, request id 1 at offset 16 because\nfailed to decode integer at offset 19 because\ntype is 0x01 not 0x02.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x09,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14, request id 1 at offset 16, error 0x0000000000000000 at offset 19 because\nfailed to decode integer at offset 22 because\ncan only handle 8-byte integers, not 9.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x01,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14, request id 1 at offset 16, error 0x0000000000000000 at offset 19 because\nfailed to decode integer at offset 22 because\ntype is 0x01 not 0x02.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x03,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14, request id 1 at offset 16, error 0x0000000000000000 at offset 19, error index 0 at offset 22, 3rd sequence type 0x30 and length 19 bytes at offset 25 because\nfailed to decode param oid and value sequence at offset offset 27 because\nfailed to decode oid at offset 29 because\ntype is 0x03 not 0x06.");
  }

  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA3,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x30,0x00
        });
    
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
  }
  catch(xju::Exception const& e) {
    xju::assert_equal(readableRepr(e),"Failed to decode snmp v2c set request from 46 bytes of data having successfully decoded sequence type 0x30 and length 44 bytes, snmp version 2c at offset 2, community \"private\" at offset 5, 2nd sequence type 0xa3 and length 30 bytes at offset 14, request id 1 at offset 16, error 0x0000000000000000 at offset 19, error index 0 at offset 22, 3rd sequence type 0x30 and length 19 bytes at offset 25 because\nfailed to decode param oid and value sequence at offset offset 27 because\nfailed to decode one int/string/oid/null etc value at offset 44 because\ndecoding of type 0x30 is not implemented.");
  }
  try {
    std::vector<uint8_t> x({
        0x30,0x2c,0x02,0x01,0x01,0x04,0x07,0x70,0x72,0x69,0x76,0x61,0x74,0x65,0xA1,0x1E,0x02,0x01,0x01,0x02,0x01,0x00,0x02,0x01,0x00,0x30,0x13,0x30,0x11,0x06,0x0D,0x2B,0x06,0x01,0x04,0x01,0x94,0x78,0x01,0x02,0x07,0x03,0x02,0x00,0x05,0x00
          });
    std::pair<SnmpV2cSetRequest,std::vector<Oid> > r(decodeSnmpV2cSetRequest(x));
    SnmpV2cSetRequest y(r.first);
    xju::assert_never_reached();
  }
  catch(RequestTypeMismatch const& e) {
    xju::assert_equal(e.cause().first,"expected request of type 0xa3 but got request of type 0xa1");
  }
  catch(xju::Exception const& e) {
    xju::assert_not_equal(readableRepr(e),readableRepr(e));
  }

}
}
}

using namespace xju::snmp;

int main(int argc, char* argv[])
{
  unsigned int n(0);
  test1(), ++n;
  test2(), ++n;
  std::cout << "PASS - " << n << " steps" << std::endl;
  return 0;
}

