// Copyright (c) 2019 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <hcp/ast.hh>
#include <hcp/parser.hh>
#include <xju/uri/parseURI.hh> //impl
#include <xju/http/RequestTarget.hh>
#include <xju/uri/pctDecode.hh> //impl
#include <xju/uri/segmentChars.hh> //impl
#include <xju/prev.hh> //impl

namespace xju
{
namespace http
{
class OriginFormTag{};
class AbsoluteFormTag{};
class AuthorityFormTag{};
class AsteriskFormTag{};

namespace
{

typedef hcp_ast::TaggedItem<OriginFormTag> OriginForm;
typedef hcp_ast::TaggedItem<AbsoluteFormTag> AbsoluteForm;
typedef hcp_ast::TaggedItem<AuthorityFormTag> AuthorityForm;
typedef hcp_ast::TaggedItem<AsteriskFormTag> AsteriskForm;


using hcp_parser::hexDigit;
using hcp_parser::listOf;
using hcp_parser::parseLiteral;
using hcp_parser::parseOneOfChars;
using hcp_parser::digit;
using hcp_parser::alpha;
using hcp_parser::atLeastOne;
using hcp_parser::zeroOrMore;

hcp_parser::PR originForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<OriginForm>(
      "request-target origin-form",
      atLeastOne(parseLiteral("/")+xju::uri::segment())+
      (
        (parseLiteral("?")+xju::uri::query())|
        !parseLiteral("?"))));
  return result;
}

hcp_parser::PR absoluteForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AbsoluteForm>(
      "HTTP request-target absolute-form",
      xju::uri::parseAbsoluteURI()));
  return result;
}

hcp_parser::PR authorityForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AuthorityForm>(
      "HTTP request-target authority-form",
      xju::uri::authority()));
  return result;
}

hcp_parser::PR asteriskForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AsteriskForm>(
      "HTTP request-target asterisk-form",
      parseLiteral("*")));
  return result;
}

xju::path::AbsFile normAbsPath(
  std::vector<xju::uri::Segment> const& p) throw(
    // could not normalise i.e. invalid path
    xju::Exception)
{
  try{
    std::vector<xju::path::DirName> d;
    std::transform(p.begin(),p.end(),
                   std::back_inserter(d),
                   [](xju::uri::Segment const& x){
                     return xju::path::DirName(x._);
                   });
    xju::path::AbsolutePath y(d);
    if (y.size()){
      return xju::path::AbsFile(
        xju::path::AbsolutePath(
          std::vector<xju::path::DirName>(y.begin(),xju::prev(y.end()))),
        xju::path::FileName((*(xju::prev(y.end())))._));
    }
    return xju::path::AbsFile(y,xju::path::FileName(""));
  }
  catch(xju::Exception& e){
    std::ostringstream s;
    s << "normalise absolute path with components "
      << xju::format::join(p.begin(),p.end(),", ");
    e.addContext(s.str(),XJU_TRACED);
    throw;
  }
}
            
xju::path::AbsFile getPath(hcp_ast::Item const& in) throw(
  // could not normalise i.e. invalid path
  xju::Exception)
{
  auto const segments{hcp_ast::findChildrenOfType<xju::uri::SegmentItem>(in)};
  std::vector<xju::uri::Segment> result;
  std::transform(segments.begin(),segments.end(),
                 std::back_inserter(result),
                 [](decltype(*segments.begin()) const& x){
                   return xju::uri::Segment(
                     xju::uri::pctDecode(xju::uri::segmentChars(),
                               hcp_ast::reconstruct(x.get())));
                 });
  return normAbsPath(result);
}

}


class RequestTargetParser : public hcp_parser::NamedParser_
{
public:
  class Item : public hcp_ast::Item
  {
  public:
    Item(RequestTarget requestTarget,
         hcp_ast::I begin,
         hcp_ast::I end) noexcept:
        hcp_ast::Item(begin,end),
        requestTarget_(std::move(requestTarget))
    {
    }
    RequestTarget requestTarget_;
  };
  
  explicit RequestTargetParser() throw():
      p_(
        originForm()|
        absoluteForm()|
        authorityForm()|
        asteriskForm())
  {
  }
  
  virtual std::string target() const throw() override
  {
    return "RFC7230 (HTTP) Request Target";
  }
  virtual hcp_parser::ParseResult parse_(
    hcp_ast::I const at, 
    hcp_parser::Options const& options) throw() override
  {
    auto const r{p_->parse(at,options)};
    if (!r.failed()){
      {
        auto const f(hcp_ast::findChildrenOfType<OriginForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          try{
            auto path(getPath(f.front().get()));
            auto query(xju::uri::getQuery((*r).first));
            return hcp_parser::ParseResult(
              hcp_parser::PV(
                {hcp_ast::IR(new Item(RequestTarget(
                                        std::move(path),
                                        std::move(query)),
                                      at,
                                      (*r).second))},
                (*r).second));
          }
          catch(xju::Exception& e){
            std::string const cause(readableRepr(e,false,true));
            return hcp_parser::ParseResult(
              hcp_parser::Exception(
                std::shared_ptr<hcp_parser::Exception::Cause const>(
                  new hcp_parser::FixedCause(cause)),
                f.front().get().begin(),
                XJU_TRACED));
          }
        }
      }
      {
        auto const f(hcp_ast::findChildrenOfType<AbsoluteForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          xju::uri::Scheme const scheme{
            hcp_ast::reconstruct(
              hcp_ast::findOnlyChildOfType<xju::uri::SchemeItem>(
                hcp_ast::Item((*f.begin()).get().items())))};
          auto authority(
            xju::uri::getAuthority(
              hcp_ast::findChildrenOfType<xju::uri::AuthorityItem>(
                *(f.begin()))));
          try{
            auto path(getPath((*f.begin()).get()));
            auto query(xju::uri::getQuery((*f.begin()).get().items()));
            return hcp_parser::ParseResult(
              hcp_parser::PV(
                {hcp_ast::IR(new Item(RequestTarget(
                                        std::move(scheme),
                                        std::move(authority.value()),
                                        std::move(path),
                                        std::move(query)),
                                      at,
                                      (*r).second))},
                (*r).second));
          }
          catch(xju::Exception& e){
            std::string const cause(readableRepr(e,false,true));
            return hcp_parser::ParseResult(
              hcp_parser::Exception(
                std::shared_ptr<hcp_parser::Exception::Cause const>(
                  new hcp_parser::FixedCause(cause)),
                f.front().get().begin(),
                XJU_TRACED));
          }
          
        }
      }
      {
        auto const f(hcp_ast::findChildrenOfType<AuthorityForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          auto authority(
            xju::uri::getAuthority(
              hcp_ast::findChildrenOfType<xju::uri::AuthorityItem>(
                *(f.begin()))));
          return hcp_parser::ParseResult(
            hcp_parser::PV(
              {hcp_ast::IR(new Item(RequestTarget(
                                      std::move(authority.value())),
                                    at,
                                    (*r).second))},
              (*r).second));
        }
      }
      auto const f(hcp_ast::findChildrenOfType<AsteriskForm>(
                     hcp_ast::Item((*r).first)));
      xju::assert_not_equal(f.size(),0U);
      return hcp_parser::ParseResult(
        hcp_parser::PV(
          {hcp_ast::IR(new Item(RequestTarget(),
                                at,
                                (*r).second))},
          (*r).second));
    }
    return r;
  }
private:
  hcp_parser::PR p_;

};
typedef RequestTargetParser::Item RequestTargetItem;

// return RFC7230 (HTTP) request-target parser
hcp_parser::PR requestTarget_() noexcept
{
  static hcp_parser::PR result(
    hcp_parser::PR(new RequestTargetParser));
  return result;
}

}
}
