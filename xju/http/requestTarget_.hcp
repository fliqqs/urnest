// Copyright (c) 2019 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <hcp/ast.hh>
#include <hcp/parser.hh>
#include <xju/uri/parseURI.hh> //impl
#include <xju/http/RequestTarget.hh>
#include <xju/uri/pctDecode.hh> //impl
#include <xju/uri/segmentChars.hh> //impl
#include <xju/prev.hh> //impl

namespace xju
{
namespace http
{
class OriginFormTag{};
class AbsoluteFormTag{};
class AuthorityFormTag{};
class AsteriskFormTag{};

namespace
{

typedef hcp_ast::TaggedItem<OriginFormTag> OriginForm;
typedef hcp_ast::TaggedItem<AbsoluteFormTag> AbsoluteForm;
typedef hcp_ast::TaggedItem<AuthorityFormTag> AuthorityForm;
typedef hcp_ast::TaggedItem<AsteriskFormTag> AsteriskForm;


using hcp_parser::hexDigit;
using hcp_parser::listOf;
using hcp_parser::parseLiteral;
using hcp_parser::parseOneOfChars;
using hcp_parser::digit;
using hcp_parser::alpha;
using hcp_parser::atLeastOne;
using hcp_parser::zeroOrMore;

hcp_parser::PR originForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<OriginForm>(
      "request-target origin-form",
      atLeastOne(parseLiteral("/")+xju::uri::segment())+
      (
        (parseLiteral("?")+xju::uri::query())|
        !parseLiteral("?"))));
  return result;
}

hcp_parser::PR absoluteForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AbsoluteForm>(
      "HTTP request-target absolute-form",
      xju::uri::parseAbsoluteURI()));
  return result;
}

hcp_parser::PR authorityForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AuthorityForm>(
      "HTTP request-target authority-form",
      xju::uri::authority()));
  return result;
}

hcp_parser::PR asteriskForm() noexcept
{
  static hcp_parser::PR result(
    new hcp_parser::NamedParser<AsteriskForm>(
      "HTTP request-target asterisk-form",
      parseLiteral("*")));
  return result;
}

xju::uri::Path getPath(hcp_ast::Item const& in) noexcept
{
  auto const segments{hcp_ast::findChildrenOfType<xju::uri::SegmentItem>(in)};
  std::vector<xju::uri::Segment> result({xju::uri::Segment("")});
  std::transform(segments.begin(),segments.end(),
                 std::back_inserter(result),
                 [](decltype(*segments.begin()) const& x){
                   return xju::uri::Segment(
                     xju::uri::pctDecode(xju::uri::segmentChars(),
                               hcp_ast::reconstruct(x.get())));
                 });
  return result;
}

}


class RequestTargetParser : public hcp_parser::NamedParser_
{
public:
  class Item : public hcp_ast::Item
  {
  public:
    Item(RequestTarget requestTarget,
         hcp_ast::I begin,
         hcp_ast::I end) noexcept:
        hcp_ast::Item(begin,end),
        requestTarget_(std::move(requestTarget))
    {
    }
    RequestTarget requestTarget_;
  };
  
  explicit RequestTargetParser() throw():
      p_(
        originForm()|
        absoluteForm()|
        asteriskForm()| //note * is a valid authority by rfc3986
                        //so we reverse order of asterisk, authority
        authorityForm())
  {
  }
  
  virtual std::string target() const throw() override
  {
    return "RFC7230 (HTTP) Request Target";
  }
  virtual hcp_parser::ParseResult parse_(
    hcp_ast::I const at, 
    hcp_parser::Options const& options) throw() override
  {
    auto const r{p_->parse(at,options)};
    if (!r.failed()){
      {
        auto const f(hcp_ast::findChildrenOfType<OriginForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          xju::assert_equal(f.size(),1U);
          auto path(getPath(f.front().get()));
          auto query(xju::uri::getQuery((*r).first));
          return hcp_parser::ParseResult(
            hcp_parser::PV(
              {hcp_ast::IR(new Item(RequestTarget(
                                      std::move(path),
                                      std::move(query)),
                                    at,
                                    (*r).second))},
              (*r).second));
        }
      }
      {
        auto const f(hcp_ast::findChildrenOfType<AbsoluteForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          xju::assert_equal(f.size(),1U);
          xju::uri::URIParser::Item const& u(
            hcp_ast::findOnlyChildOfType<xju::uri::URIParser::Item>(
              f.front().get()));
          try{
            return hcp_parser::ParseResult(
              hcp_parser::PV(
                {hcp_ast::IR(new Item(RequestTarget(
                                        u.uri_.scheme_,
                                        u.uri_.authority_,
                                        u.uri_.path_,
                                        u.uri_.query_),
                                      at,
                                      (*r).second))},
                (*r).second));
          }
          catch(xju::Exception& e){
            std::string const cause(readableRepr(e,false,true));
            return hcp_parser::ParseResult(
              hcp_parser::Exception(
                std::shared_ptr<hcp_parser::Exception::Cause const>(
                  new hcp_parser::FixedCause(cause)),
                f.front().get().begin(),
                XJU_TRACED));
          }
          
        }
      }
      {
        auto const f(hcp_ast::findChildrenOfType<AuthorityForm>(
                       hcp_ast::Item((*r).first)));
        if (f.size()){
          auto authority(
            xju::uri::getAuthority(
              hcp_ast::findChildrenOfType<xju::uri::AuthorityItem>(
                *(f.begin()))));
          return hcp_parser::ParseResult(
            hcp_parser::PV(
              {hcp_ast::IR(new Item(RequestTarget(
                                      std::move(authority.value())),
                                    at,
                                    (*r).second))},
              (*r).second));
        }
      }
      auto const f(hcp_ast::findChildrenOfType<AsteriskForm>(
                     hcp_ast::Item((*r).first)));
      xju::assert_not_equal(f.size(),0U);
      return hcp_parser::ParseResult(
        hcp_parser::PV(
          {hcp_ast::IR(new Item(RequestTarget(),
                                at,
                                (*r).second))},
          (*r).second));
    }
    return r;
  }
private:
  hcp_parser::PR p_;

};
typedef RequestTargetParser::Item RequestTargetItem;

// return RFC7230 (HTTP) request-target parser
hcp_parser::PR requestTarget_() noexcept
{
  static hcp_parser::PR result(
    hcp_parser::PR(new RequestTargetParser));
  return result;
}

}
}
