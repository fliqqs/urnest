// Copyright (c) 2018 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <memory>
#include <xju/Exception.hh>
#include <xju/assert.hh> //impl
#include <sstream> //impl
#include <xju/json/Element.hh>
#include <hcp/parser.hh> //impl
#include <xju/json/Number.hh> //impl
#include <hcp/ast.hh> //impl
#include <xju/Utf8String.hh>

namespace xju
{
namespace json
{

// parse s assuming it is valid JSON
std::shared_ptr<xju::json::Element const> parse(
  xju::Utf8String const& s) throw(
    // x is not valid JSON
    xju::Exception);

namespace
{

// Subclasses of each json Element type, to capture the
// line and column that each element was parsed at, which
// can then be included in diagnostics.
//
class ParsedNumber : public xju::json::Number
{
public:
  ParsedNumber(std::string const& value,
               unsigned int atLine,
               unsigned int atColumn) noexcept
    :xju::json::Number(value),
     atLine_(atLine),
     atColumn_(atColumn)
  {
  }
  unsigned int atLine_;
  unsigned int atColumn_;

  virtual std::string str() const noexcept override
  {
    std::ostringstream s;
    s << Number::str() << " (at line " << atLine_
      << " column " << atColumn_ << ")";
    return s.str();
  }
};

// hcp_ast::Item type tree mirroring json Element type tree
class AstElement : public hcp_ast::CompositeItem
{
public:
  AstElement(std::vector<hcp_ast::IR>& items,
             std::shared_ptr<xju::json::Element const> const& element) throw()
      : hcp_ast::CompositeItem(items),
        element_(element)
  {
  }
  std::shared_ptr<xju::json::Element const> const element_;
};

class AstNumber : public AstElement
{
public:
  explicit AstNumber(std::vector<hcp_ast::IR>& items) noexcept
      :AstElement(items,AstNumber::convert(items))
  {
  }
private:
  std::shared_ptr<xju::json::Number const> convert(
    std::vector<hcp_ast::IR>& items) noexcept
  {
    xju::assert_not_equal(items.size(),0U);
    return std::shared_ptr<xju::json::Number const>(
      new xju::json::ParsedNumber(
        std::string(items.front()->begin(),items.back()->end()),
        items.front()->begin().line_,
        items.front()->begin().column_));
  }
};

hcp_parser::PR digit() noexcept
{
  static hcp_parser::PR result(hcp_parser::charInRange('0','9'));
  return result;
}

hcp_parser::PR nonZeroDigit() noexcept
{
  static hcp_parser::PR result(hcp_parser::charInRange('1','9'));
  return result;
}

hcp_parser::PR exponent() noexcept
{
  static hcp_parser::PR result(
    hcp_parser::parseOneOfChars("eE")+
    hcp_parser::optional(hcp_parser::parseOneOfChars("+-"))+
    hcp_parser::atLeastOne(digit()));
  return result;
}

hcp_parser::PR number() noexcept
{
  static hcp_parser::PR result(
    hcp_parser::PR(
      new hcp_parser::NamedParser<AstNumber>(
        "number",
        hcp_parser::optional(hcp_parser::parseOneOfChars("-"))+
        (hcp_parser::parseLiteral("0")|
         (nonZeroDigit()+
          hcp_parser::zeroOrMore()*digit()))+
        (!hcp_parser::parseLiteral(".")|
         hcp_parser::parseLiteral(".")+
         hcp_parser::atLeastOne(digit()))+
        ((!hcp_parser::parseOneOfChars("eE"))|exponent())))+
    hcp_parser::eatWhite());
  return result;
}

// hcp_parser::PR array() noexcept
// {
//   static hcp_parser::PR result{
//     new hcp_parser::NamedParser<AstArray>(
//       "array",
      
// }

hcp_parser::PR element() noexcept
{
  static hcp_parser::PR result(
    number()/*|
    bool()|
    string()|
    array()|
    map()|
    null()
    ... */);
  return result;
}

}

// (declared above)
std::shared_ptr<xju::json::Element const> parse(
  xju::Utf8String const& json) throw(
    xju::Exception)
{
  std::string const& s{json};
  auto v(hcp_parser::parseString(s.begin(),s.end(),
                                 hcp_parser::eatWhite()+element()));
  return hcp_ast::findOnlyChildOfType<AstElement>(v).element_;
}

}
}
