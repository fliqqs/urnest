// Copyright (c) 2018 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <memory>
#include <xju/Exception.hh>
#include <xju/assert.hh> //impl
#include <xju/stringToDouble.hh> //impl
#include <sstream> //impl
#include <xju/json/Double.hh> //impl
#include <xju/json/Element.hh>
#include <hcp/parser.hh> //impl

namespace xju
{
namespace json
{

namespace
{
class ParsedDouble : public xju::json::Double
{
  ParsedDouble(long double value,
               unsigned int atLine,
               unsigned int atColumn) noexcept
    :xju::json::Double(value),
     atLine_(atLine),
     atColumn_(atColumn)
  {
  }
  unsigned int atLine_;
  unsigned int atColumn_;
  
  virtual std::string str() const noexcept override
  {
    std::ostringstream s;
    s << Double::str() << " (at " << at_.atLine_ << ":" << atColumn_ << ")";
    return s.str();
  }
};
class ParsedUInt : public xju::json::UInt
{
  ParsedDouble(std::uintmax_t value,
               unsigned int atLine,
               unsigned int atColumn) noexcept
    :xju::json::UInt(value),
     atLine_(atLine),
     atColumn_(atColumn)
  {
  }
  unsigned int atLine_;
  unsigned int atColumn_;
  
  virtual std::string str() const noexcept override
  {
    std::ostringstream s;
    s << UInt::str() << " (at " << at_.atLine_ << ":" << atColumn_ << ")";
    return s.str();
  }
};

class AstElement : public hcp_ast::CompositeItem
{
public:
  AstElement(std::vector<IR const>& items,
             std::shared_ptr<xju::json::Element const> const& element) throw()
      : hcp_ast::CompositeItem(items),
        element_(element)
  {
  }
  std::shared_ptr<xju::json::Element const> const element_;
};

class AstDouble : public Element
{
public:
  explicit AstDouble(std::vector<IR const>& items) noexcept
      :AstElement(items,AstDouble::convert(items))
  {
  }
private:
  std::shared_ptr<xju::json::Double> convert(
    std::vector<IR const>& items) throw(
      // too big/small
      xju::Exception)
  {
    xju::assert_not_equal(items.size(),0U);
    return new xju::json::ParsedDouble(xju::stringToDouble(
                                         items.front().begin(),
                                         items.back().end()));
  }
};

hcp_parser::PR double_() noexcept
{
  return hcp_parser::NamedParser<AstDouble>(
    "double",
    (integer()|unsignedInteger())+
    parseLiteral(".")+
    unsignedInteger()+
    (!parseOneOfChars("eE")|
     (parseOneOfChars("eE")+
      integer()|
      unsignedInteger())));
}

/*
hcp_parser::PR uint_() noexcept
{
  return hcp_parser::NamedParser<AstUInt>(
    "unsigned integer",
    hcp_parser::atLeastOne(charInRange('0','9')));
}

hcp_parser::PR int_() noexcept
{
  return hcp_parser::NamedParser<AstUInt>(
    "integer",
    hcp_parser::optional(parseOneOfChars("+-"))+ //REVISIT: + allowed?
    unsignedInteger());
}
*/

hcp_parser::PR element() noexcept
{
  static hcp_parser::PR result(
    double_()/*|
    int_()|
    uint_()|
    ... */);
  return result;
}

}

// parse json assuming it is valid JSON utf-8 string
std::shared_ptr<xju::json::Element const> parse(
  xju::Utf8String const& json) throw(
    // x is not valid JSON
    xju::Exception)
{
  auto v(hcp::parse(json,element()));
  return dynamic_cast<AstElement const&>(*v).element_;
}

}
}
