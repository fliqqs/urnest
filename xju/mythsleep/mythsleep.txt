- starts in auto, where in recording period, otherwise starts in manual
- won't shutdown with recording < 10 minutes away
- sleeps to 5 minutes to recording
- allow manual override (from client)


every 1 minute:
  - manual: do nothing
  - auto, in [ next-recoding-start-10m, next-recording-end+5m]: do
nothing
  - auto, otherwise: shutdown till 5 minutes to next recording (or
forever if no next recording)

... initially, manual = service stopped

module idl {
module xju {

struct UnixTime_GMT {
  long seconds;
  unsigned long microseconds;
};

struct ExceptionElement {
  string first;
  long second;
};

struct Exception {
  ExceptionElement cause;
  sequence<ExceptionElement> context;
};

module myth_sleep {

struct Recording {
  UnixTime_GMT start; // GMT unix seconds
  UnixTime_GMT end;
};

struct State {
  boolean auto;
  sequence<Recording> next_recording[1];
  UnixTime_GMT last_update;
  sequence<Exception> error[1];
};

interface service {
  State get_state();

  //post: get_state.auto == x
  void set_auto(bool x);
};

};
};
};

-----------
namespace xju {
namespace myth_sleep {

class State {
public:
  State(bool auto,
        Optional<std::pair<Time> > next_recording,
        Time last_update) throw():
    auto_(auto),
    next_recording_(next_recording),
    last_update_(last_update) {
  }
  bool auto_;
  Optional<std::pair<Time> > next_recording_;
  Time last_update_;
  Optional<Exception> error_;
};

class Service {
public:
  Service(db_name, db_user, db_password) throw();
  void run() throw();
  void stop() throw();

  State get_state() const throw();
  void set_auto(bool x) throw();

private:
  std::string const db_name_;
  std::string const db_user_;
  std::string const db_password_;

  Mutex guard_;
  State state_;

  void update_state() throw();
};

}
}


mysql -u mythtv -p mythconverg

select a.title,a.starttime,c.startoffset,a.endtime,c.endoffset from
program a, recordmatch b, record c where a.starttime = b.starttime and
a.chanid = b.chanid and b.recordid = c.recordid;

... then need to see if maxepisodes stop it recording... and there's
probably lots of other rules - could steal the code I guess:-(

select count(recordid) from recorded where recordid=283;

+---------------------+
| starttime           |
+---------------------+
| 2008-05-10 19:30:00 | 
| 2008-05-11 20:30:00 | 
+---------------------+
2 rows in set (0.00 sec)

http://www.mythtv.org/wiki/index.php/ACPI_Wakeup#User_experience

mysql> select title, maxepisodes, maxnewest from record;
+----------------------+-------------+-----------+
| title                | maxepisodes | maxnewest |
+----------------------+-------------+-----------+
| Doc Martin           |           0 |         0 | 
| Lunar Jim            |           5 |         0 | 
| Roary The Racing Car |           4 |         0 | 
| Grey's Anatomy       |           0 |         0 | 
| Life on Mars         |           2 |         0 | 
| In The Night Garden  |           6 |         1 | 
| The Gruen Transfer   |           0 |         0 | 
| Euro 2008            |           0 |         0 | 
| Private Practice     |           0 |         0 | 
| Hi-5                 |           5 |         0 | 
+----------------------+-------------+-----------+
10 rows in set (0.00 sec)

maxnewest 0 = don't record if max episodes
maxnewest 1 = discard oldest if max episodes

