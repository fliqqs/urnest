// Copyright (c) 2019 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <xju/linux/wtmp/Event.hh>
#include <xju/path.hh>
#include <xju/SyscallFailed.hh>
#include <sstream> //impl
#include <vector>
#include <memory>
#include <chrono>
#include <sys/stat.h> //impl
#include <utility> //impl
#include <iterator> //impl
#include <xju/io/select.hh> //impl
#include <xju/steadyNow.hh> //impl
#include <xju/io/FileObserver.hh>
#include <xju/io/FileReader.hh>
#include <xju/Exception.hh>
#include <utmp.h> //impl
#include <iostream> //impl
#include <xju/format.hh> //impl
#include <xju/unix_epoch.hh> //impl
#include <xju/startsWith.hh> //impl
#include <algorithm> //impl
#include <set>
#include <unistd.h>
#include <deque>

namespace xju
{
namespace linux
{
namespace wtmp
{

namespace {
bool sameFile(struct stat const& a, struct stat const& b) noexcept
{
  return (a.st_dev==b.st_dev)&&(a.st_ino==b.st_ino);
}
std::string toString(char const* const begin,
                     char const* const end) noexcept
{
  char const* e{begin};
  for(; e!=end && (*e)!=0; ++e){
  }
  return std::string(begin,e);
}

}

class LoginLogoutMonitor
{
public:
  explicit LoginLogoutMonitor(xju::path::AbsFile const& wtmp) throw(
    // - wtmp.first - i.e. directory of wtmp - does not exist (ENOENT)
    // - no resources
    xju::SyscallFailed) try:
    wtmp_(wtmp),
    notifier_({wtmp})
  {
  }
  catch(xju::SyscallFailed& e){
    std::ostringstream s;
    s << "monitor logins/logouts recorded by wtmp file "
      << xju::path::str(wtmp);
    e.addContext(s.str(),XJU_TRACED);
    throw;
  }

  // not thread safe
  std::vector<std::shared_ptr<Event const> > readEventsUntilDeadline(
    std::chrono::steady_clock::time_point const& deadline) throw(
      xju::Exception)
  {
    std::vector<std::shared_ptr<Event const> > result;
    do
    {
      // cases to deal with:
      // - file wtmp_ has never existed (i.e. never successfully opened it)...
      //     ... and still doesn't [1]
      //     ... and does now [2]
      // - file existed (i.e. we have it open) and has been renamed
      //     ... new file has not yet been created [3]
      //     ... new file has been created [4]
      // - open fails [5]
      // - also want to work where the writer continues to write to old
      //   for an arbitrary amount of time after opening the new file [6]
      // - also where new file is never written to before it is replaced,
      //   ... but is written to after it is replaced [7]
      try{
        std::unique_ptr<xju::io::FileReader> newFile{
          new xju::io::FileReader(wtmp_)};
        if (currentFiles_.size()==0 ||
            !sameFile(currentFiles_.back()->stat(),newFile->stat())){
          currentFiles_.push_back(std::move(newFile));
        }
      }
      catch(xju::SyscallFailed const& e){
        if (e._errno!=ENOENT){ // [5]
          throw;
        }
        //named wtmp file does not exist, which might be transient ([1] or [3])
      }
      auto newestRead{currentFiles_.begin()};
      for(auto i=currentFiles_.begin();i!=currentFiles_.end();++i){
        if (readNewEntries(**i,std::back_inserter(result))){
          newestRead==i;
        }
      }
      currentFiles_.erase(currentFiles_.begin(),newestRead);
      xju::io::select(inputs(),deadline);
    }
    while(xju::steadyNow()<deadline);
    return result;
  }

  // post: 0 not in result
  std::set<xju::io::Input const*> inputs() noexcept
  {
    std::set<xju::io::Input const*> inputs;
    std::transform(currentFiles_.begin(),currentFiles_.end(),
                   std::inserter(inputs,inputs.end()),
                   [](std::unique_ptr<xju::io::FileReader> const& x){
                     return &*x;
                   });
    inputs.insert(&notifier_);
    return inputs;
  }
private:
  xju::path::AbsFile const wtmp_;
  xju::io::FileObserver notifier_;
  std::deque<std::unique_ptr<xju::io::FileReader> > currentFiles_;
  std::map<pid_t, UserLoggedIn const> who_;
  
  typedef std::vector<std::shared_ptr<Event const> > Events;

  // read new entries into specified iterator
  // return number of entries read
  size_t readNewEntries(xju::io::FileReader& file,
                        std::back_insert_iterator<Events> into) throw(
                          xju::Exception)
  {
    size_t result{0};
    try {
      while(true) {
        struct utmp record;
        off_t const at{file.seekBy(0)};
        size_t s{file.read(&record,sizeof(record))};
        if (s<sizeof(record)){
          // writer not writing atomically? or disk full?
          file.seekTo(at);
          return result;
        }
        else {
          result+=processRecord(
            record.ut_type,
            record.ut_pid,
            toString(record.ut_host,record.ut_host+UT_HOSTSIZE),
            toString(record.ut_user,record.ut_user+UT_NAMESIZE),
            xju::unix_epoch()+
            std::chrono::seconds(record.ut_tv.tv_sec)+
            std::chrono::microseconds(record.ut_tv.tv_usec),
            into);
        }
      }
    }
    catch(xju::io::EndOfFile) {
    }
    return result;
  }

  size_t processRecord(short ut_type,
                       pid_t ut_pid,
                       std::string host,
                       std::string user,
                       std::chrono::system_clock::time_point at,
                       std::back_insert_iterator<Events> into) noexcept
  {
    size_t result{0};
    // type: 7 host not :x.0 -> login
    // type: 7 host :x.0 -> xterm without -l
    //         - the corresponding type 8 has clear host
    //         -> need to track just to ignore
    // type: 8 sometimes has user, sometimes not (e.g. ssh) -> logout
    // type: 1 boot -> clear all
    switch(ut_type){
    case 1: {
      who_.clear();
      break;
    }
    case 7: {
      auto const i{
        who_.insert(
          std::make_pair(ut_pid,UserLoggedIn(user,host,at))).first};
      if (xju::startsWith(host,std::string(":")) &&
          std::find(host.begin(),host.end(),'.')!=host.end()){
        // e.g. :0.0 xterm without -l, i.e. already logged in so skip
        // but need to track the entry because the logout will have
        // host cleared
      }
      else {
        (*into++)=std::shared_ptr<Event>(
          new Event::USER_LOGGED_IN((*i).second));
        ++result;
      }
      break;
    }
    case 8: {
      auto const i{who_.find(ut_pid)};
      if (i!=who_.end()){
        if (xju::startsWith(host,std::string(":")) &&
            std::find(host.begin(),host.end(),'.')!=host.end()){
          // e.g. :0.0 ... see above
        }
        else {
          (*into++)=std::shared_ptr<Event>(
            new Event::USER_LOGGED_OUT(
              UserLoggedOut((*i).second,at)));
          ++result;
        }
        who_.erase(i);
      }
    }
    }
    return result;
  }
  
};

}
}
}
