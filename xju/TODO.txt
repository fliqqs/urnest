* use cstdint for int64_t etc and figure out how to use its constants
  to write code that compiles "everywhere" eg format.hh, test-format.cc, test-stringToInt, test-stringToUnsignedInt
  C++11 has long long at least 64 bits, use that in format.hh in 
  place of int64_t; put functions in place for int16, int32, int64
  and their unsigned equivs if no standard type has that size

snmp/README.txt stuff

Int,Float add operator* operator/
Float add math functions exp, sqrt, log, floor, ceiling etc

io::Input
io::Output
  - pure interfaces
  - pair<std::set<ref<Input>>,std::set<ref<Output>>> 
      io::select(std::set<ref<Input>>,std::set<ref<Output>>,Time until)
  - close on exec? only ever make stdin,stdout,stderr survive exec (and always)
  - other fd and socket options? eg udp Don't Fragment, use constructed objects
  - dup2, perhaps:
    InByteStream::useAsStdin, OutByteStream::useAsStdout, OutByteStream::useAsStderr

- io
  - InFile
  - OutFile
  - InOutFile?
  - TCPListener
  - TCPSocket
      - IStream& input()
        - is a Input
        - size_t read(void* buffer, size_t bytes, Time until);
      - OStream& output()
        - is a Output
        - size_t write(void* buffer, size_t bytes, Time until);
  - UDPSocket
      IQueue& input();
        - is a Input
        - size_t deque(void* message, size_t bytes, Time deadline);
      OQueue& output();
        - void enque(void const* message, size_t bytes, Time deadline);
        - is a Output

  - Pipe
      - shared_ptr<InByteStream> input_;
      - shared_ptr<OutByteStream> output_;
  - SocketPair
      - unique_ptr<InByteStream> input_;
      - unique_ptr<OutByteStream> output_;
  - UnixListener,UnixSocket - like TCPListener,TCPSocket
  - MessageQueue (linux allows select)
      IQueue& input();
      OQueue& input();

Subprocess
  x start function object,
  x optional stop function object (pass pid) - default kill 9
  x exit status
  - test scenarios
    - process output before destroy -> wait exit
    - exception processing -> kill

unit testing
  generic stub that captures calls, so can do test like:
    Stub<Y> y;
    X x(y);
    auto call = ut.call(x,&X::f,3,2);
    stub.calls_.awaitCall(y,&Y::g,Duration(3,0))->validateParams(3)->return_(6);
    call.awaitResult(Duration(3))->verify(3*2-2);


gcc 5.2.0:

  504  xzcat gmp-6.0.0a.tar.xz | tar xf -
  505  xzcat mpfr-3.1.3.tar.xz | tar xf -
  508  gunzip -c mpc-1.0.3.tar.gz | tar xf -
  514  cd gmp-6.0.0
  515  ./configure --prefix=/home/xju/gcc-5.2.0-run
  516  make && make install
  517  make check
  521  cd ../mpfr-3.1.3
  524  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib ./configure --with-gmp=/home/xju/gcc-5.2.0-run prefix=/home/xju/gcc-5.2.0-run
  525  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make && LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make install
  526  cd ../mpc-1.0.3
  528  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib ./configure --with-gmp=/home/xju/gcc-5.2.0-run --with-mpfr=/home/xju/gcc-5.2.0-run prefix=/home/xju/gcc-5.2.0-run
  529  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make && LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make install
  530  cd ../gcc-5.2.0
  533  sudo aptitude install zip
  531  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib ./configure --with-gmp=/home/xju/gcc-5.2.0-run --with-mpfr=/home/xju/gcc-5.2.0-run -with-mpc=/home/xju/gcc-5.2.0-run prefix=/home/xju/gcc-5.2.0-run --disable-multilib
  536  LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make && LD_LIBRARY_PATH=/home/xju/gcc-5.2.0-run/lib make install
