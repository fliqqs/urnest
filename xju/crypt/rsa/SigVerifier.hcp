// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <xju/crypt/SigVerifier.hh>

namespace xju
{
namespace crypt
{
namespace rsa
{

class SigVerifier : public xju::crypt::SigVerifier
{
public:
  explicit SigVerifier(xju::crypt::rsa::PublicKey publicKey) noexcept:
      publicKey_(std::move(publicKey))
  {
    try{
      auto const n(publicKey.n_.data());
      auto const e(publicKey.e_.data());
      gcry_sexp_t sexp(0);
      rc = gcry_sexp_build(&sexp, NULL, "(public-key(rsa(n%b)(e%b)))",
                           n.size(), n.data(),
                           e.size(), e.data());
      xju::crypt::verifySuccessful(rc,XJU_TRACED);
      sexp_=std::unique_ptr<decltype(*sexp)>(sexp,gcry_sexp_release);
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "build libgcrypt rsa public key context for RSA public key "
        << publicKey_;
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
  virtual void verifySignature(uint8_t const* x,size_t len,
                               Signature const& signature) override
  {
    try{
      auto const h(xju::crypt::hash::sha1(x,len)); //rfc4253 6.6

      // rfc8017 8.2.2 step 1
      if (signature.size()!=publicKey.keySize_.value()/8){
        std::ostringstream s;
        s << "signature size (" << signature.size()
          << " bytes) is not equal to key size ("
          << publicKey.keySize_.value()/8
          << " bytes)";
        throw xju::format::join(s.str(),XJU_TRACED);
      }
      //REVISIT: use gcrypt sexp stuff
      gcry_sexp_t s_hash_(0);
      verifySuccessful(gcry_sexp_build(&s_hash_, NULL,
                                       "(data (flags pkcs1) (hash sha1 %b))",
                                       h.size(),h.data()));
      std::unique_ptr<decltype(*s_sig_)> s_hash(s_hash_,gcry_sexp_release);

      gcry_sexp_t s_sig_(0);
      verifySuccessful(gcry_sexp_build(&s_sig_, NULL,
                                       "(sig-val(rsa(s %b)))",
                                       signature.size(),siganture.data()));
      std::unique_ptr<decltype(*s_sig_)> s_sig(s_sig_,gcry_sexp_release);
      
      verifySuccessful(gcry_pk_verify(s_sig.operator->(),
                                      s_hash.operator->(),
                                      sexp_.operator->()));
    }
    catch(xju::Explicit& e){
      std::ostringstream s;
      s << "verify that signature "
        << xju::format::join(signature.begin(),
                             signature.end(),
                             xju::format::Hex(""),
                             "")
        << " on " << len << " supplied data bytes "
        << " was signed by owner of RSA public key "
        << publicKey_;
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
private:
  xju::crypt::rsa::PublicKey publicKey_;
  std::unique_ptr<decltype(*(gcry_sexp_t)0)> sexp_;
  
};

}
}
}


