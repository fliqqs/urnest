// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
// Create, run and wait for a subprocess to exit, executing a specified
// function in that process, capturing the subprocess exit status.
//
// For example, to run command by a deadline, capturing its stdout,
// killing subprocess on timeout:
//
// std::string doCmd(std::vector<std::string> const& cmd,
//                   std::chrono::system_clock::timepoint const& deadline)
//   throw(std::bad_alloc,xju::Exception)
//   {
//     std::chrono::duration<REVISIT> const timeout(
//       deadline-std::chrono::system_clock::now());
//     try{
//       auto p(xju::pipe(true,false); // to capture output of subprocess
//       int exitStatus(0);
//       std::ostringstream output;
//       try {
//         Subprocess command([](){ 
//           p.second->useAsStdout(); // use far end of pipe as stdout
//           xju::exec(cmd);
//         ));
//         p.second.reset();//close far end of pipe in parent process
//         std::vector<char> buffer(512,0);
//         while(std::chrono::system_clock::now()<deadline){
//           buffer.resize(p.first->read(buffer.data(),512,dealine));
//           std::copy(buffer.begin(),buffer.end(),
//                     std::ostream_iterator(output));
//         }
//         throw xju::Exception("timeout",XJU_TRACED);
//
//         // note exiting this block will kill(9) the subprocess, but that
//         // has no effect if it has exited already. Exiting this block
//         // also "waits" for the subprocess, collecting its exit status
//       }
//       catch(xju::io::Input::Closed&)
//       {
//         // pipe closes when subprocess exits
//       }
//       if (exitStatus!=0){
//         std::ostringstream s;
//         s << "command failed with status " << exitStatus;
//         throw xju::Exception(s.str(),XJU_TRACED);
//       }
//     }
//     catch(xju::Exception& e){
//       std::ostringstream s;
//       s << "run " << xju::format::join(cmd," ") << " within "
//         xju::format::float(timeout.count()) << "s";
//       e.addContext(s.str(),XJU_TRACED);
//     }
//
#include "xju/Exception.hh"
#include "xju/unistd.hh"
#include "xju/signal.hh" //impl
#include "xju/wait.hh"
#include <memory>
#include <sys/types.h>
#include "xju/NonCopyable.hh"



namespace xju
{

class Subprocess : NonCopyable
{
public:
  // call start() in Subprocess with process id pid_, set exitStatus
  // to exit status of Subprocess, which is result of start() unless
  // Subprocess calls exec, is killed or aborts
  // - exitStatus is not valid until destuctor completes
  // - destructor issues kill(9) and waits until Subprocess exits
  // - exitStatus must outlive Subprocess
  // int start() throw()
  template<class F>
  Subprocess(int& exitStatus, F start) throw(
    xju::Exception):
      exitStatus_(exitStatus),
      impl_(new Stop),
      pid_(xju::fork())
  {
    if (!pid_) {
      ::exit::start();
    }
  }
  // as above, but destructor calls stop(pid_) before waiting for
  // Subprocess to terminate
  // 
  // int start() throw()
  // void stop(pid_t pid) throw()
  template<class F1, class F2>
  Subprocess(int& exitStatus, F1 start, F2 stop) throw(
    xju::Exception):
      exitStatus_(exitStatus),
      impl_(new Stop2(stop)),
      pid_(xju::fork())
  {
    if (!pid_) {
      ::exit(start());
    }
  }
  void kill(int signal) throw(
    xju::Exception)
  {
    xju::kill(pid_,signal);
  }

  ~Subprocess() throw()
  {
    impl_->stop(pid_);
    xju::waitpid(pid_,&exitStatus_,0);
  }
  
private:
  int& exitStatus_;
  std::unique_ptr<Stop> impl_;
  pid_t pid_;

  class Stop
  {
  public:
    virtual ~Stop() throw()
    {
    }
    virtual void f(pid_t pid) throw()
    {
      xju::kill(pid, 9);
    }
  };
  
  template<class F>
  class Stop2: public Stop
  {
  public:
    stop2(F stop) throw()
      stop_(stop)
    {
    }
    virtual void f(pid_t pid) throw()
    {
      stop_(pid);
    }
    F stop_;
  };
};

  
}
