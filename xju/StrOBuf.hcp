// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <unistd.h>
#include <string>
#include <xju/assert.hh> //impl
#include <algorithm> //impl
#include <utility>
#include <limits>
#include <xju/OBuf.hh>

namespace xju
{

class StrOBuf : public OBuf
{
public:
  // buffer up to max bytes, extending storage space from 0 in inc-sized
  // increments as needed
  StrOBuf(
    size_t const inc,
    size_t const max=std::numeric_limits<size_t>::max()) noexcept:
      inc_(inc),
      max_(max),
      valid_(0)
  {
  }
  // content flushed-so-far
  // - note this does not include bytes "added" since last flush()
  // - result is valid until next flush
  std::pair<std::string::const_iterator,std::string::const_iterator> str() const noexcept
  {
    return std::make_pair(str_.begin(),str_.begin()+valid_);
  }
  // OBuf::
  // - extends buffer iff it is full and not at max size
  // - returned range empty means we are at max size
  // - note use flush(0) initially
  virtual std::pair<uint8_t*,uint8_t*> flush(uint8_t* to) override
  // bad_alloc
  {
    xju::assert_less_equal(to,end());
    if (to>mark()){
      valid_=to-begin();
    }
    if (mark()==end()){
      auto const extra(std::min(inc_,max_-str_.size()));
      str_.resize(str_.size()+extra);
    }
    return std::make_pair(mark(),end());
  }
  
private:
  size_t const inc_;
  size_t const max_;
  std::string str_;
  size_t valid_;
  
  inline uint8_t* begin() const noexcept{return (uint8_t*)&str_[0];}
  inline uint8_t* mark() const noexcept {return begin()+valid_;}
  inline uint8_t* end() const noexcept  {return begin()+str_.size();}
};

}
