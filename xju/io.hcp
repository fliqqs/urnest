// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
#include <utility>
#include <set>
#include <chrono>
#include <new>
#include <xju/syscall.hh> //impl
#include <xju/unistd.hh> //impl
#include <sys/select.h> //impl

namespace xju
{
namespace io
{

class Input;
class Output;

// wait at most until deadline for one of the specified inputs or outputs
// to be readable/writable; return as soon as one is, returning all that are
// - returns empty sets when deadline is reached
// - returns those inputs/outputs that are already readable/writable if
//   deadline has already passed
// post: result.first.size()||result.second.size()||deadline reached
std::pair<std::set<ref<Input> >,std::set<ref<Output> > > select(
  std::set<ref<Input> > const& inputs,
  std::set<ref<Output> > const& outputs,
  std::chrono::system_clock::time_point const& deadline) throw(
    std::bad_alloc)
{
  std::pair<std::set<ref<Input> >,std::set<ref<Output> > > result;
  int n;
  do {
    fd_set r;
    FD_ZERO(&r);
    for(auto x : inputs) {
      FD_SET(&r,x.fileDescriptor());
    }
    for(auto x : outputs) {
      FD_SET(&w,x.fileDescriptor());
    }
    std::chrono::system_clock::duration const timeout(
      std::min(deadline-std::chrono::system_clock::now(),
               std::chrono::duration(
                 std::chrono::seconds(std::numeric_limits<long>::max()))));
    struct timeval timeout_;
    timeout_.tv_sec=std::chrono::seconds(timeout);
    timeout_.tv_usec=std::chrono::microseconds(timeout);
    n=::select(FD_SETSIZE,&r,&w,0,&timeout_);
    switch(n) {
    case 0:
      break;
    case -1:
      if (errno != EINTR)
      {
        xju::assert_equal(errno,ENOMEM);
        throw std::bad_alloc();
      }
      break;
    default:
      for(auto x : inputs) {
        if (FD_ISSET(&r,x.fileDescriptor())) {
          result.first.insert(x);
        }
      }
      for(auto x : outputs) {
        if (FD_ISSET(&w,x.fileDescriptor())) {
          result.second.insert(x);
        }
      }
    }
  }
  while(result.first.size()==0 &&
        result.second.size()==0 &&
        std::chrono::system_clock::now()<deadline);
  return result;
}

// as above but without any outputs
// 
std::set<ref<Input> > select(
  std::set<ref<Input> > const& inputs,
  std::chrono::system_clock::time_point const& deadline) throw(
    xju::SyscallFailed)
{
  return select(inputs,std::set<ref<Output> >(),deadline).first;
}

// as above but without any inputs
// 
std::set<ref<Output> > select(
  std::set<ref<Output> > const& outputs,
  std::chrono::system_clock::time_point const& deadline) throw(
    std::bad_alloc)
{
  return select(std::set<ref<Iutput> >(),outputs,deadline).second;
}

class Input
{
public:
  virtual ~Input() throw()
  {
  }
  // in-line human readable description
  virtual std::string str() const throw()=0;
  
protected:
  virtual int fileDescriptor() const throw() = 0;

friend std::pair<std::set<ref<Input> >,std::set<ref<Output> > > select(
  std::set<ref<Input> > const& inputs,
  std::set<ref<Output> > const& outputs,
  std::chrono::system_clock const& deadline) throw(
    std::bad_alloc);

};
std::ostream& operator<<(std::ostream& s, Input const& x) throw()
{
  return s << x.str();
}

class Output
{
public:
  virtual ~Output() throw()
  {
  }
  // in-line human readable description
  virtual std::string str() const throw()=0;

protected:
  virtual int fileDescriptor() const throw() = 0;

friend std::pair<std::set<ref<Input> >,std::set<ref<Output> > > select(
  std::set<ref<Input> > const& inputs,
  std::set<ref<Output> > const& outputs,
  std::chrono::system_clock const& deadline) throw(
    std::bad_alloc);
};
std::ostream& operator<<(std::ostream& s, Output const& x) throw()
{
  return s << x.str();
}

class IStream : public Input
{
public:
  // read bytes into buffer until deadline reached or bufferSize bytes read
  // or end of input is reached
  // - return number of bytes read
  // - reads any immediately available bytes if deadline has already passed
  size_t read(void* buffer, size_t bufferSize,
              std::chrono::system_clock::timepoint deadline) throw(
                std::bad_alloc,
                // eg disk error
                xju::Exception) {
    size_t bytesRead(0);
    try {
      uint8_t* p((uint8_t*)buffer);
      while(bytesRead<bufferSize &&
            select({*this},deadline).size()) {
        size_t const thisRead=xju::read(
          fileDescriptor(),
          std::min(bufferSize-bytesRead,std::numeric_limits<ssize_t>::max()));
        if (thisRead==0) {
          //end of input
          return bytesRead;
        }
        bytesRead+=thisRead;
      }
      return bytesRead;
    }
    catch(xju::Exception& e)
    {
      std::ostringstream s;
      s << "read bytes from " << (*this)
        << "until " << deadline << " or " << (bufferSize-bytesRead) 
        << " more (of " << bufferSize << " total) bytes read "
        << "or end of input";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
};

class OStream : public Output
{
public:
  // write bytes from buffer until bufferSize bytes written or
  // deadline reached or output closed
  // - return number of bytes written
  // - writes what is possible immediately if deadline has already passed
  // - returns immediately if output closes before deadline
  size_t write(void const* buffer, size_t bufferSize,
               std::chrono::system_clock::timepoint deadline) throw(
                 std::bad_alloc,
                // eg disk error
                 xju::Exception) {
    size_t bytesWrote(0);
    try {
      uint8_t const* p((uint8_t const*)buffer);
      uint8_t* p((uint8_t*)buffer);
      while(bytesRead<bufferSize &&
            select({*this},deadline).size()) {
        size_t const thisWrite=xju::write(
          fileDescriptor(),
          std::min(bufferSize-bytesWrote,std::numeric_limits<ssize_t>::min()));
        if (thisWrite==0) {
          //output closed
          return bytesWrote;
        }
        bytesWrote+=thisWrite;
      }
      return bytesWrote;
    }
    catch(xju::Exception& e)
    {
      std::ostringstream s;
      s << "write bytes to " << (*this)
        << "until " << deadline << " or " << (bufferSize-bytesWrote) 
        << " more (of " << bufferSize << " total) bytes written "
        << "or output closed";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
};

}
}
