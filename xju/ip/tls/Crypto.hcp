// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <atomic>
namespace xju
{
namespace ip
{
namespace tls
{

class Crypto
{
public:
  Crypto() throw(xju::Exception);

  void run() noexcept
  {
    xju::Lock l(sessionsGuard_);
    while(!stop_){
      std::set<xju::io::Input const*> readable{wake_.first.get()};
      std::set<xju::io::Input const*> writable;
      for(auto s: sessions_){
        readable.insert(s.first);
        writable.insert(s.first);
      }
      auto x(xju::io::select(readable,writable,xju::steadyEternity()));
      {
        xju::Lock l(newSessionsGuard_);
        while(newSessions_.size()){
          sessions_.insert(newSessions_.pop());
        }
      }
      {
        uint8_t x;
        wake_.first->read(&x,1,xju::steadyNow());
      }
      do reads and writes @@@;
    }
  }
  void stop(){
    stop_=true;
    wake_.write('x',1,xju::steadyNow());
  }
  //
  // transport must live until get<1>(result) is closed
  // - to request closure, close get<0>(result)
  std::tuple<
    std::unique_ptr<xju::io::OStream>,
    std::unique_ptr<xju::io::IStream>,
    xju::Optional<std::pair<Certificate,bool> > > accept(
      xju::ip::Socket& transport,
      bool const requestClientCertificate,
      std::chrono::steady_clock::time_point const& deadline,
      bool const closeOnExec) throw(xju::Exception)
  {
    try{
      auto plainOut(xju::pipe());
      auto plainIn(xju::pipe());
      xju::CircularBuffer<uint8_t> rxBuf(2048);
      xju::CircularBuffer<uint8_t> txBuf(2048);
      std::unique_ptr<SSL,SSL_Deref> ssl(SSL_new(ctx));
      @@@;
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "accept TLS connection on transport socket by "
        << deadline
        << (requestClientCertificate?" ":" without ")
        << "requesting client certificate";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
private:
  std::atomic<bool> stop_;

  struct Session{
    Session(std::unique_ptr<xju::io::OStream>&& plainOut_,
            std::unique_ptr<xju::io::IStream>&& plainIn_,
            xju::CircularBuffer<uint8_t>&& rxBuf_,
            xju::CircularBuffer<uint8_t>&& txBuf_,
            std::unique_ptr<SSL,SSL_Deref> ssl_) noexcept:
        plainOut_(plainOut),
        plainIn_(plainIn),
        rxBuf_(rxBuf),
        txBuf_(txBuf),
        ssl_(ssl){
    }
    std::unique_ptr<xju::io::OStream> plainOut_;
    std::unique_ptr<xju::io::IStream> plainIn_;
    xju::CircularBuffer<uint8_t> rxBuf_;
    xju::CircularBuffer<uint8_t> txBuf_;
    std::unique_ptr<SSL,SSL_Deref> ssl_;
  };
             
  std::pair<std::unique_ptr<xju::io::IStream>,
            std::unique_ptr<xju::io::OStream> > wake_;

  xju::Mutex sessionsGuard_;
  std::map<xju::ip::TCPSocket*, std::unique_ptr<Session> > sessions_;
  
};

}
}
}
