// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <atomic>
namespace xju
{
namespace ip
{
namespace tls
{
namespace{
  // get calling thread error messages, separate them by " and "
  std::string getCallingThreadErrors() noexcept
  {
    std::vector<std::string> errs;
    auto cb=[errs&](const char *str, size_t len, void *u)->int{
              errs.push_back(std::string(str,str+len));
            };
    ERR_print_errors_cb(cb,0);
    return xju::format::join(errs.begin(),errs.end()," and ");
  }
  
  std::unique_ptr<SSL_CTX,decltype(&SSL_CTX_free)> createContext(
    decltype(&SSLv23_server_method),//client or server?
    PrivateKey const& privateKey,
    std::vector<X509Certificate> const& certificateAndAncestors) /*throw(
      xju::Exception)*/
  {
    try{
      std::unique_ptr<SSL_CTX,decltype(&SSL_CTX_free)> result(
        SSL_CTX_new(method));
      if (!result.get()) {
        throw xju::Exception(getCallingThreadErrors(),XJU_TRACED);
      }
      //REVISIT: what type of private key? How does that correspond to cipher list?
      SSL_CTX_set_cipher_list("HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4:!DSS");//from wiki.openssl.org
      SSL_CTX_set_ecdh_auto(result.get(), 1);
      if (certificateAndAncestors.size()){
        if (SSL_CTX_use_certificate(
              result.get(),
              certificateAndAncestors.front().get()) <= 0) {
          xju::Exception e(getErrors(),XJU_TRACED);
          e.addContext("set context certificate",XJU_TRACED);
          throw e;
        }
        for(int i=1; i!=certificateAndAncestors.size(); ++i){
          if (iSSL_CTX_add_extra_chain_cert(
                result.get(),
                certificateAndAncestors[i].get()) <= 0) {
            xju::Exception e(getErrors(),XJU_TRACED);
            e.addContext(
              "add ancestor certificate #"+xju::format::str(i),XJU_TRACED);
            throw e;
          }
        }
      }
      if (SSL_CTX_use_PrivateKey(result.get(),privateKey.get())<=0){
        xju::Exception e(getErrors(),XJU_TRACED);
        e.addContext("set context private key",XJU_TRACED);
        throw e;
      }
      return result;
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "create OpenSSL server-side context";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
}

class Crypto
{
public:
  Crypto(decltype(&SSLv23_server_method),//client or server?
         PrivateKey const& privateKey,
         std::vector<X509Certificate> const& certificateAndAncestors,
         bool const requestClientCertificate) /*throw(
           xju::Exception)*/:
      ctx_(createContext(method,privateKey,certificateAndAncestors)),
      stop_(false),
      wake_(xju::pipe())
  {
  }

  void run() noexcept
  {
    xju::Lock l(sessionsGuard_);
    while(!stop_){
      std::set<xju::io::Input const*> readable{wake_.first.get()};
      std::set<xju::io::Input const*> writable;
      for(auto s: sessions_){
        readable.insert(s.first);
        writable.insert(s.first);
      }
      auto x(xju::io::select(readable,writable,xju::steadyEternity()));
      {
        xju::Lock l(newSessionsGuard_);
        while(newSessions_.size()){
          sessions_.insert(newSessions_.pop());
        }
      }
      if(x.first.find(wake_.first.get())!=x.first.end()){
        uint8_t x;
        wake_.first->read(&x,1,xju::steadyNow());
      }
      do reads and writes @@@;
    }
  }
  void stop(){
    stop_=true;
    wake_.write('x',1,xju::steadyNow());
  }
  //
  // transport must live until get<1>(result) is closed
  // - to request closure, close get<0>(result)
  std::tuple<
    std::unique_ptr<xju::io::OStream>,
    std::unique_ptr<xju::io::IStream>,
    xju::Optional<std::pair<Certificate,bool> > > accept(
      xju::ip::Socket& transport,
      bool const requestClientCertificate,
      std::chrono::steady_clock::time_point const& deadline,
      bool const closeOnExec) /*throw(xju::Exception)*/
  {
    try{
      auto decrypted(xju::pipe());
      auto encrypt(xju::pipe());
      xju::CircularBuffer<uint8_t> rxBuf(2048);
      xju::CircularBuffer<uint8_t> txBuf(2048);
      std::unique_ptr<SSL,SSL_Deref> ssl(SSL_new(ctx_),&SSL_free);
      if(requestClientCertificate){
        SSL_set_verify(result.get(),
                       SSL_VERIFY_PEER,
                       [](int preverify_ok, X509_STORE_CTX *x509_ctx)->int {
                         return 1;
                       });
      }
      REVISIT do handshake;
      std::unique_ptr<Session> session(
        new Session(decrypted.second,
                    encrypt.first,
                    rxBuf,
                    txBuf,
                    ssl));
      
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "accept TLS connection on transport socket by "
        << deadline
        << (requestClientCertificate?" ":" without ")
        << "requesting client certificate";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
private:
  std::unique_ptr<SSL_CTX,decltype(&SSL_CTX_free)> const ctx_;
  
  std::atomic<bool> stop_;
  typedef std::unique_ptr<SSL,SSL_decltype(&SSL_free)> SSLuptr;
  
  struct Session{
    Session(std::unique_ptr<xju::io::OStream>&& decrypted,
            std::unique_ptr<xju::io::IStream>&& encrypt,
            xju::CircularBuffer<uint8_t>&& rxBuf,
            xju::CircularBuffer<uint8_t>&& txBuf,
            SSLuptr ssl_) noexcept:
        decrypted_(decrypted),
        encrypt_(encrypt),
        rxBuf_(rxBuf),
        txBuf_(txBuf),
        ssl_(ssl){
    }
    std::unique_ptr<xju::io::OStream> decrypted_;
    std::unique_ptr<xju::io::IStream> encrypt_;
    xju::CircularBuffer<uint8_t> rxBuf_;
    xju::CircularBuffer<uint8_t> txBuf_;
    SSLuptr ssl_;
  };
             
  std::pair<std::unique_ptr<xju::io::IStream>,
            std::unique_ptr<xju::io::OStream> > wake_;

  xju::Mutex sessionsGuard_;
  std::map<xju::ip::TCPSocket*, std::unique_ptr<Session> > sessions_;

  xju::Mutext newSessionsGuard_;
  std::deque<std::unique_ptr<Session> > newSessions_;
};

}
}
}
