// Copyright (c) 2018 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <unistd.h>
#include <chrono>
#include <xju/DeadlineReached.hh>
#include "xju/AutoFd.hh"

#include <sstream> //impl
#include <bitset> //impl
#include "xju/syscall.hh"
#include "xju/socket.hh" //impl
#include "xju/io/select.hh" //impl
#include "xju/format.hh" //impl
#include <xju/ip/checksum/calculate.hh> //impl
#include <xju/ip/decode.hh> //impl
#include <xju/ip/icmp/encodeMessage.hh> //impl

namespace xju
{
namespace ip
{
namespace icmp
{

class Socket : public SocketIf
{
public:
  Socket() throw(
    xju::Exception,
    xju::SyscallFailed) try:
      fd_(xju::syscall(xju::socket,XJU_TRACED)(
            AF_INET, SOCK_RAW|SOCK_CLOEXEC|SOCK_NONBLOCK, IPPROTO_ICMP))
  {
    std::bitset<256> o;
    o[0]=true; //echo reply
    o[3]=true; //destination unreachable
    o.flip(); // ICMP_FILTER is "exclude"
    xju::syscall(xju::setsockopt,XJU_TRACED)(
      fd_,IPPROTO_ICMP,ICMP_FILTER,o.data(),256/8)
  }
  catch(xju::SyscallFailed& e)
  {
    std::ostringstream s;
    s << "create ICMP-only RAW socket";
    e.addContext(s.str(),XJU_TRACED);
    throw;
  }
  
  void send(
    xju::ip::v4::Address const& to,
    Message const& x,
    std::chrono::steady_clock::time_point const& deadline) throw(
      xju::SyscallFailed) override
  {
    try{
      if (xju::io::select({(xju::io::Output*)this},deadline).size()) {
        sockaddr_in dest_addr;
        dest_addr.sin_family=AF_INET;
        dest_addr.sin_port=0;
        dest_addr.sin_addr.s_addr=::htonl(to.value());

        std::vector<uint8_t> m;
        Message y{x};
        y.checksum_=0;
        encodeMessage(y,std::back_inserter(m));
        y.checksum_=actualChecksum{
          xju::ip::checksum::calculate(
            xju::ip::decode::makeIterator(m.begin(),m.end()))};
        encodeMessage(y,m.begin());
        auto const bytesSent=xju::syscall(xju::sendto,XJU_TRACED)(
          fileDescriptor(),
          m.data(),
          m.size(),
          MSG_NOSIGNAL,
          (sockaddr*)&dest_addr,
          sizeof(dest_addr));
        if (bytesSent<size) {
          std::ostringstream s;
          s << "only sent " << bytesSent << " bytes of " << m.size();
          throw xju::DeadlineReached(xju::Exception(s.str(),XJU_TRACED));
        }
        return;
      }
      std::ostringstream s;
      s << "deadline reached before socket writable";
      throw xju::DeadlineReached(xju::Exception(s.str(),XJU_TRACED));
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "send ICMP message " << message << " to " << to;
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }

  std::tuple<xju::ip::v4::Addresss,Message> receive() throw(
    xju::SyscallFailed,
    // invalid message, e.g. incorrect checksum
    xju::Exception) override
  {
    try{
      sockaddr_in senderAddr;
      socklen_t senderAddrLen{sizeof(senderAddr)};
      std::array<uint8_t,2048> buffer;
      ssize_t const bytesRead=xju::syscall(xju::recvfrom,XJU_TRACED)(
        fileDescriptor(),
        buffer.data(),buffer.size(),
        MSG_NOSIGNAL,
        &(sockaddr*)&senderAddr,&senderAddrLen);
      if (senderAddrLen!=sizeof(senderAddr)){
        std::ostringstream s;
        s << "recvfrom() returned unexpected from-address length "
          << senderAddrLen << " (expected " << sizeof(senderAddr) << ")";
        throw xju::Exception(s.str(),XJU_TRACED);
      }
      try{
        xju::ip::checksum::validate(
          xju::ip::decode::makeIterator(
            buffer.begin(),buffer.begin()+bytesRead));
      }
      catch(xju::Exception& e){
        std::ostringstream s;
        s << "validate checksum in received ICMP message";
        e.addContext(s.str(),XJU_TRACED);
        throw;
      }
      auto const m{decodeMessage(
          xju::ip::decode::makeIterator(
            buffer.begin(),buffer.begin()+bytesRead))};
      if (!m.second.atEnd()){
        std::ostringstream s;
        s << "extra "
          << (bytesRead-m.second.currentOffset().first)
          << " bytes after decoded ICMP message " << m.first
          << " from " << m.second.currentOffset();
        throw xju::Exception(s.str(),XJU_TRACED);
      }
      return std::make_tuple(
        xju::ip::v4::Address(::ntohl(senderAddr.sin_addr.s_addr)),
        m.first);
    }
    catch(xju::Exception& e){
      std::ostringstream s;
      s << "get next ICMP message assuming it has already arrived";
      e.addContext(s.str(),XJU_TRACED);
      throw;
    }
  }
private:
  xju::AutoFd fd_;
  // xju::io::Input::
  // xju::io::Output::
  int fileDescriptor() const throw() {
    return fd_.fd();
  }
  
};


}
}
}


