// generated from p4.idl by omnicxy cxyobjref idl backend specifying 
// cxy::Exception from <cxy/Exception.hh> as base class for all ipc exceptions
#include "p4.hh"
#include "p4.cdr.hh"

#include <cxy/objref.hh>
#include <cxy/translateException.hh>
#include <cxy/pof.hh>

#include <xju/NonCopyable.hh>
#include <xju/Optional.hh>

#include <omniORB4/CORBA.h>
#include <omniORB4/callDescriptor.h>
#include <omniORB4/IOP_C.h>

// included idl
#include "p3.objref.hh"

namespace cxy
{

template<>
class objref< ::p4::F>:
  public virtual ::p4::F,
  public virtual ::CORBA::Object,
  public virtual omniObjRef,
  public xju::NonCopyable
{
public:
  inline objref()  { _PR_setobj(0); }  // nil
  objref(omniIOR* ior, omniIdentity* id) throw() :
      omniObjRef(cxy::cdr< ::p4::F>::repoId, ior, id, 1) {
    _PR_setobj(this);
  }
  std::string uri_;

    
  // p4::F::
  ::p4::XS1 f1(
    ::p4::XS1 const& p1) throw(
    cxy::Exception)
  {
    try {
      try {
        calldesc::f1 c("f1", 2+1, 0,
        p1);
        _invoke(c);
      return c.r_.value();
      }
      catch(CORBA::Exception const& ee) {
        throw cxy::translateException< cxy::Exception>(ee);
      }
    }
    catch(cxy::Exception& e) {
      e.addContext(uri_+"->p4::F::f1()", std::make_pair(__FILE__, __LINE__));
      throw;
    }
  }
    
  // p4::F::
  ::p4::F::XxPair f2(
    ::p4::F::XxPair const& p1) throw(
    cxy::Exception)
  {
    try {
      try {
        calldesc::f2 c("f2", 2+1, 0,
        p1);
        _invoke(c);
      return c.r_.value();
      }
      catch(CORBA::Exception const& ee) {
        throw cxy::translateException< cxy::Exception>(ee);
      }
    }
    catch(cxy::Exception& e) {
      e.addContext(uri_+"->p4::F::f2()", std::make_pair(__FILE__, __LINE__));
      throw;
    }
  }
  

protected:
  virtual ~objref() throw(){
  }
  
private:
  class calldesc
  {
  public:
        
    class f1 : public omniCallDescriptor
    {
    public:
      f1(
        const char* op_,
        size_t oplen,
        _CORBA_Boolean upcall,
        ::p4::XS1 const& p1) throw():
          omniCallDescriptor(
            &f1::lcfn, op_, oplen, 0, _user_exns, 0, upcall),
          p1_(p1)
      {
      }
      
      ::p4::XS1 const p1_;
      xju::Optional< ::p4::XS1> r_;
    
      // omniCallDescriptor::
      void marshalArguments(cdrStream& s) // REVISIT: throw
      {
        cxy::cdr< ::p4::XS1>::marshal(p1_, s);
      }
      void unmarshalReturnedValues(cdrStream& s) // REVISIT: throw
      {
        r_=cxy::cdr< ::p4::XS1>::unmarshalFrom(s);
      }
      void userException(cdrStream& s,
                         omni::IOP_C* iop_client,
                         const char* repoId)//REVISIT: throw
      {
        if (iop_client) iop_client->RequestCompleted(1);
        OMNIORB_THROW(UNKNOWN,omni::UNKNOWN_UserException,
                      (::CORBA::CompletionStatus)s.completion());
      }
    
      static void lcfn(omniCallDescriptor* calldesc, omniServant* svnt)
      {
        ::p4::F* impl=(::p4::F*)svnt->_ptrToInterface(cxy::cdr< ::p4::F>::repoId);
        f1* cd((f1*)calldesc);
        
        cd->r_= impl->f1(
          cd->p1_);
      }
      static const char* const _user_exns[] = {
        0
      };
    };
        
    class f2 : public omniCallDescriptor
    {
    public:
      f2(
        const char* op_,
        size_t oplen,
        _CORBA_Boolean upcall,
        ::p4::F::XxPair const& p1) throw():
          omniCallDescriptor(
            &f2::lcfn, op_, oplen, 0, _user_exns, 0, upcall),
          p1_(p1)
      {
      }
      
      ::p4::F::XxPair const p1_;
      xju::Optional< ::p4::F::XxPair> r_;
    
      // omniCallDescriptor::
      void marshalArguments(cdrStream& s) // REVISIT: throw
      {
        cxy::cdr< ::p4::F::XxPair>::marshal(p1_, s);
      }
      void unmarshalReturnedValues(cdrStream& s) // REVISIT: throw
      {
        r_=cxy::cdr< ::p4::F::XxPair>::unmarshalFrom(s);
      }
      void userException(cdrStream& s,
                         omni::IOP_C* iop_client,
                         const char* repoId)//REVISIT: throw
      {
        if (iop_client) iop_client->RequestCompleted(1);
        OMNIORB_THROW(UNKNOWN,omni::UNKNOWN_UserException,
                      (::CORBA::CompletionStatus)s.completion());
      }
    
      static void lcfn(omniCallDescriptor* calldesc, omniServant* svnt)
      {
        ::p4::F* impl=(::p4::F*)svnt->_ptrToInterface(cxy::cdr< ::p4::F>::repoId);
        f2* cd((f2*)calldesc);
        
        cd->r_= impl->f2(
          cd->p1_);
      }
      static const char* const _user_exns[] = {
        0
      };
    };
    
  };
  // CORBA::Object::
  virtual void* _ptrToObjRef(const char* repoId)
  {
    if (repoId == cxy::cdr< ::p4::F>::repoId)
      return this;
    
    if (omni::strMatch(repoId, cxy::cdr< ::p4::F>::repoId))
      return this;
    
    if (repoId == ::CORBA::Object::_PD_repoId)
      return (::CORBA::Object_ptr) this;
    
    if (omni::strMatch(repoId, ::CORBA::Object::_PD_repoId))
      return (::CORBA::Object_ptr) this;
    
    return 0;
  }
};

template<>
class pof< ::p4::F> : public omni::proxyObjectFactory {
public:
  pof() : omni::proxyObjectFactory(cxy::cdr< ::p4::F>::repoId){
  }
  virtual ~pof()
  {
  }
  
  virtual omniObjRef* newObjRef(omniIOR* ior,omniIdentity* id)
  {
    return new cxy::objref< ::p4::F>(ior, id);
  }
  
  virtual _CORBA_Boolean is_a(const char* repoId) const
  {
    if (repoId==cxy::cdr< ::p4::F>::repoId ||
        omni::ptrStrMatch(repoId, cxy::cdr< ::p4::F>::repoId)) {
      return 1;
    }
    return 0;
  }

  static pof< ::p4::F>& me_() throw()
  {
    return me;
  }
  static pof< ::p4::F> me;
};

}

