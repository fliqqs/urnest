// generated from p1.idl by omni cxy_cref idl backend specifying 
// xju::Exception from "xju/Exception.hh" as base class for all exceptions
#include <cxy/cref.hh>
#include <cxy/exceptions.hh>
#include <cxy/ORB.hh>

#include "p1.hh"

#include "p1.objref.hh" // impl
#include "p1.cdr.hh" // impl
#include <cxy/translateException.hh> // impl
#include <xju/format.hh> // impl
#include <xju/assert.hh> // impl

namespace cxy
{
template<class T>
class objref;

template<>
class cref< ::p1::F>
{
public:
  explicit cref(cxy::ORB<xju::Exception>& orb, std::string const& uri) throw(
    // no object with specified uri, including server
    // not reachable and server does not know name
    cxy::Exceptions<xju::Exception>::NoSuchObject,
    // object with specified uri is not a p1::F
    cxy::Exceptions<xju::Exception>::WrongType,
    // other failure, eg communication failure
    xju::Exception):
      uri_(uri),
      obj_(0)
  {
    try {
      try {
        CORBA::Object_var x(orb.impl_.orb_->string_to_object(uri.c_str()));
        if (CORBA::is_nil(x)) {
          std::ostringstream s;
          s << xju::format::quote(uri) << " is nil";
          throw cxy::Exceptions<xju::Exception>::NoSuchObject(
            s.str(), std::make_pair(__FILE__, __LINE__));
        }
        cxy::objref< ::p1::F>* e = 
          (cxy::objref< ::p1::F>*)
          x->_PR_getobj()->_realNarrow(cxy::cdr< ::p1::F>::repoId);
        if (e==0) {
          std::ostringstream s;
          s << xju::format::quote(uri) << " is not a "
            << cxy::cdr< ::p1::F>::repoId;
          throw cxy::Exceptions<xju::Exception>::WrongType(
            s.str(), std::make_pair(__FILE__, __LINE__));
        }
      }
      catch(CORBA::Exception const& ee) {
        throw cxy::translateException<xju::Exception>(ee);
      }
    }
    catch(xju::Exception& e) {
      std::ostringstream s;
      s << "locate object "
        << xju::format::quote(uri)
        << " of type "
        << cxy::cdr< ::p1::F>::repoId;
      e.addContext(s.str(), __FILE__, __LINE__);
      throw e;
    }
  }
  
  cref(cref const& b) throw():
      uri_(b.uri_),
      obj_(b.obj_)
  {
    if (obj_ && !obj_->_NP_is_nil())  omni::duplicateObjRef(obj_);
  }

  cref< ::p1::F>& operator=(cref< ::p1::F> const& b) throw()
  {
    if (this != &b) {
      ::CORBA::release(obj_);
      uri_= b.uri_;
      obj_ = b.obj_;
      if (obj_ && !obj_->_NP_is_nil())  omni::duplicateObjRef(obj_);
    }
    return *this;
  }

  ~cref() throw()
  {
    ::CORBA::release(obj_);
  }
  
  void f1() throw(
    // ipc failure
    xju::Exception)
  {
    xju::assert_not_equal(obj_, (void*)0);
    xju::assert_not_equal(true, obj_->_NP_is_nil());
    obj_->f1();
  }

  p1::F* operator->() throw()
  {
    return obj_;
  }
  p1::F const* operator->() const throw()
  {
    return obj_;
  }
  
private:
  std::string uri_;
  cxy::objref< ::p1::F>* obj_;
};
}
