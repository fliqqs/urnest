// generated from p3.idl by omnicxy cxycref idl backend specifying 
// cxy::Exception from <cxy/Exception.hh> as base class for all exceptions
#include <cxy/cref.hh>
#include <cxy/Exceptions.hh>
#include <cxy/Exception.hh>

#include "p3.hh"

#include "p3.objref.hh" // impl
#include "p3.cdr.hh" // impl
#include <cxy/ORB.hh> // impl
#include <cxy/translateException.hh> // impl
#include <xju/format.hh> // impl
#include <xju/assert.hh> // impl
#include <string>

namespace cxy
{
template<class E>
class ORB;

template<class T>
class objref;

template<>
class cref< ::p3::F>
{
public:
  explicit cref(cxy::ORB<cxy::Exception>& orb, std::string const& uri) throw(
    // no object with specified uri, including server
    // not reachable and server does not know name
    cxy::Exceptions<cxy::Exception>::NoSuchObject,
    // object with specified uri is not a p3::F
    cxy::Exceptions<cxy::Exception>::WrongType,
    // other failure, eg communication failure
    cxy::Exception):
      uri_(uri),
      obj_((&cxy::pof< ::p3::F>::me_(), // force init of static var,
            (cxy::objref< ::p3::F>*)orb.locate(
              uri, cxy::cdr< ::p3::F>::repoId)))
  {
  }
  
  cref(cref const& b) throw():
      uri_(b.uri_),
      obj_(b.obj_)
  {
    if (obj_ && !obj_->_NP_is_nil())  omni::duplicateObjRef(obj_);
  }

  cref< ::p3::F>& operator=(cref< ::p3::F> const& b) throw()
  {
    if (this != &b) {
      ::CORBA::release(obj_);
      uri_= b.uri_;
      obj_ = b.obj_;
      if (obj_ && !obj_->_NP_is_nil())  omni::duplicateObjRef(obj_);
    }
    return *this;
  }

  ~cref() throw()
  {
    ::CORBA::release(obj_);
  }
  
  p3::F* operator->() throw()
  {
    return obj_;
  }
  p3::F const* operator->() const throw()
  {
    return obj_;
  }
  
private:
  std::string uri_;
  cxy::objref< ::p3::F>* obj_;
};

}

