// generated from p7.idl by omni cxy idl backend specifying 
// E from "E.hh" as base class for all ipc exceptions

#include "E.hh"
#include <xju/Int.hh>
#include <string>
#include <stdint.h>
#include <xju/Tagged.hh>


#include <cxy/copyContext.hh> //impl

namespace p7
{
struct SourceRefPair : public std::pair< std::string, uint32_t>
{
  SourceRefPair(std::string const& p1, uint32_t const& p2) throw():
     std::pair< std::string, uint32_t>(p1, p2) {
  }
  template<class T1, class T2>
  explicit SourceRefPair(std::pair<T1, T2> const& x) throw():
     std::pair< std::string, uint32_t>(x) {
  }
  friend bool operator<(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    if (x.first < y.first) return true;
    if (y.first < x.first) return false;
    return false;
  }
  friend bool operator>(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    return y<x;
  }
  friend bool operator!=(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    return (x<y)||(y<x);
  }
  friend bool operator==(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    return !(x!=y);
  }
  friend bool operator<=(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    return (x<y)||(x==y);
  }
  friend bool operator>=(
    SourceRefPair const& x, 
    SourceRefPair const& y) throw() {
    return (x>y)||(x==y);
  }
};

struct CausePair : public std::pair< std::string, ::p7::SourceRefPair>
{
  CausePair(std::string const& p1, ::p7::SourceRefPair const& p2) throw():
     std::pair< std::string, ::p7::SourceRefPair>(p1, p2) {
  }
  template<class T1, class T2>
  explicit CausePair(std::pair<T1, T2> const& x) throw():
     std::pair< std::string, ::p7::SourceRefPair>(x) {
  }
  friend bool operator<(
    CausePair const& x, 
    CausePair const& y) throw() {
    if (x.first < y.first) return true;
    if (y.first < x.first) return false;
    return false;
  }
  friend bool operator>(
    CausePair const& x, 
    CausePair const& y) throw() {
    return y<x;
  }
  friend bool operator!=(
    CausePair const& x, 
    CausePair const& y) throw() {
    return (x<y)||(y<x);
  }
  friend bool operator==(
    CausePair const& x, 
    CausePair const& y) throw() {
    return !(x!=y);
  }
  friend bool operator<=(
    CausePair const& x, 
    CausePair const& y) throw() {
    return (x<y)||(x==y);
  }
  friend bool operator>=(
    CausePair const& x, 
    CausePair const& y) throw() {
    return (x>y)||(x==y);
  }
};

struct ContextPair : public std::pair< std::string, ::p7::SourceRefPair>
{
  ContextPair(std::string const& p1, ::p7::SourceRefPair const& p2) throw():
     std::pair< std::string, ::p7::SourceRefPair>(p1, p2) {
  }
  template<class T1, class T2>
  explicit ContextPair(std::pair<T1, T2> const& x) throw():
     std::pair< std::string, ::p7::SourceRefPair>(x) {
  }
  friend bool operator<(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    if (x.first < y.first) return true;
    if (y.first < x.first) return false;
    return false;
  }
  friend bool operator>(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    return y<x;
  }
  friend bool operator!=(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    return (x<y)||(y<x);
  }
  friend bool operator==(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    return !(x!=y);
  }
  friend bool operator<=(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    return (x<y)||(x==y);
  }
  friend bool operator>=(
    ContextPair const& x, 
    ContextPair const& y) throw() {
    return (x>y)||(x==y);
  }
};

typedef ::p7::CausePair ExceptionCause;
typedef std::vector< ::p7::ContextPair> ExceptionContext;
struct E1 : E
{
  E1(
    ::p7::ExceptionCause const& p1,
    ::p7::ExceptionContext const& p2) throw():
      E(
        p1.first, 
        p1.second) {
    cxy::copyContext(p2.begin(), 
                     p2.end(), 
                     *this);
  }

  // pre: E(T) constructs a E
  template<class T>
  explicit E1(
    T const& p) throw():
      E(p) {
  }
  
  // pre: E(T1,T2) constructs a E
  template<class T1, class T2>
  explicit E1(
    T1 const& p1,
    T2 const& p2) throw():
      E(p1,p2) {
  }
  
  friend bool operator<(
    E1 const& x, 
    E1 const& y) throw() {
    return (E const&)x < (E const&)y;
  }
  friend bool operator>(
    E1 const& x, 
    E1 const& y) throw() {
    return y<x;
  }
  friend bool operator!=(
    E1 const& x, 
    E1 const& y) throw() {
    return (x<y)||(y<x);
  }
  friend bool operator==(
    E1 const& x, 
    E1 const& y) throw() {
    return !(x!=y);
  }
  friend bool operator<=(
    E1 const& x, 
    E1 const& y) throw() {
    return (x<y)||(x==y);
  }
  friend bool operator>=(
    E1 const& x, 
    E1 const& y) throw() {
    return (x>y)||(x==y);
  }
};

class F
{
public:
  virtual ~F() throw()
  {
  }
  virtual void f1() throw(
    p7::E1,
    // ipc failure
    // - note servant may not throw
    E) = 0;
  virtual void f2() throw(
    p7::E1,
    // ipc failure
    // - note servant may not throw
    E) = 0;
};

}
