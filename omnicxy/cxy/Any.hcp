// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include "typecode.hh"
#include "cdr.hh"
#include <cxy/CDRMemOStream.hh> //impl

namespace cxy
{

class Any
{
public:
  Any(cxy::typecode::Kind kind,
      std::string repoId,
      std::vector<uint8_t> cdrEncodedTypeCode,
      std::vector<uint8_t> cdrEncodedValue) throw():
      kind_(kind),
      repoId_(repoId),
      cdrEncodedTypeCode_(cdrEncodedTypeCode),
      cdrEncodedValue_(cdrEncodedValue), {
  }
  
  cxy::typecode::Kind kind_;
  std::string repoId_;
  std::vector<uint8_t> cdrEncodedTypeCode_;
  std::vector<uint8_t> cdrEncodedValue_;
};

template<>
class cdr<Any>
{
public:
  static Any unmarshalFrom(cdrStream& s) 
  //to avoid needing CORBA.h in our .hh, excepiton specs are commented
  //throw(
  //  CORBA::SystemException,
  //  omni::giopStream::CommFailure
  //  )
  {
    std::unique_ptr<cxy::TypeCode> const t(
      cdr<std::unique_ptr<cxy::TypeCode> >::unmarshalFrom(s));
    cxy::Any result(t.kind(),
                    t.repoId(),
                    std::vector<uint8_t>(),
                    std::vector<uint8_t>());
    cxy::CdrMemOStream ts(result.cdrEncodedTypeCode_);
    cxy::CdrMemOStream vs(result.cdrEncodedValue_);
    cdr<std::unique_ptr<cxy::TypeCode> >::marshal(t,ts);
    t->copyValue(s, vs);
    return result;
  }
  static void marshal(Any const& x, cdrStream& s)
  //to avoid needing CORBA.h in our .hh, excepiton specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    s.put_octet_array(&x.cdrEncodedTypeCode_[0],x.cdrEncodedTypeCode_.size());
    s.put_octet_array(&x.cdrEncodedValue_[0],x.cdrEncodedValue_.size());
  }
};
  
}
