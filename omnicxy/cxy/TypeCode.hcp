// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <cxy/cdr.hh>
#include <cxy/TypeKind.hh>
#include <cxy/TypeTag.hh>

#include <omniORB4/CORBA.h> //impl
#include <omniORB4/cdrStream.h> //impl
#include <xju/format.hh>//impl
#include <cxy/EncapsulationCdrStream.hh>//impl
#include <memory>
#include <vector>
#include <typeinfo>
#include <typeindex> //impl
#include <cxy/MemCdrStream.hh>
#include <xju/Optional.hh>

class cdrStream;

namespace cxy
{

// CORBA 3.3 9.3.5.1 TypeCode
//
// TypeCode describes a type well enough to marshal and unmarshal
// objects of that type without their IDL definitions.
//
class TypeCode
{
public:
  virtual ~TypeCode() throw(){}

  virtual void copyValue(cdrStream& from, cdrStream& to) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  virtual void marshal(cdrStream& s) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  virtual bool equals(TypeCode const& b) const throw() = 0;

  //pre: typeid(*this)==typeid(b)
  virtual bool lessThan(TypeCode const& b) const throw() = 0;
  
  virtual std::string str() const throw() = 0;
};
std::ostream& operator<<(std::ostream& s, TypeCode const& x) throw()
{
  return s << x.str();
}

bool operator==(TypeCode const& a, TypeCode const& b) throw()
{
  return a.equals(b);
}
bool operator<(TypeCode const& a, TypeCode const& b) throw()
{
  if (std::type_index(typeid(a))<std::type_index(typeid(b))){
    return true;
  }
  if (std::type_index(typeid(b))<std::type_index(typeid(a))){
    return false;
  }
  return a.lessThan(b);
}


//typecode class for eg CORBA::Short (ie int16_t)
template<class BasicType, cxy::TypeKind typeKind>
class BasicTypeCode : public TypeCode
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    cxy::cdr<BasicType>::marshal(
      cxy::cdr<BasicType>::unmarshalFrom(from),
      to);
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)typeKind, s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    BasicTypeCode const* b_(dynamic_cast<BasicTypeCode const*>(&b));
    return b_;
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    return false;
  }
  virtual std::string str() const throw()
  {
    return typeid(BasicType).name();
  }
};

class SequenceTypeCode : public TypeCode
{
public:
  SequenceTypeCode(std::shared_ptr<TypeCode> itemType,
                   uint32_t maxSize):
      itemType_(itemType),
      maxSize_(maxSize)
  {
  }
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    uint32_t const size(
      cxy::cdr<uint32_t>::unmarshalFrom(from));
    cxy::cdr<uint32_t>::marshal(size,to);
    // deliberately don't check max size
    for(uint32_t i=0; i != size; ++i) {
      itemType_->copyValue(from,to);
    }
  }

  virtual void marshal(cdrStream& s) const
  {
    EncapsulationCdrStream es;
    itemType_->marshal(*es);
    cxy::cdr<uint32_t>::marshal(maxSize_,*es);

    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::SEQUENCE, s);
    cxy::cdr<EncapsulationCdrStream>::marshal(es,s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    SequenceTypeCode const* b_(dynamic_cast<SequenceTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    SequenceTypeCode const& a_(static_cast<SequenceTypeCode const&>(*this));
    SequenceTypeCode const& b_(static_cast<SequenceTypeCode const&>(b));
    if (*a_.itemType_ < *b_.itemType_){
      return true;
    }
    if (*b_.itemType_ < *a_.itemType_){
      return false;
    }
    return a_.maxSize_ < b_.maxSize_;
  }
  virtual std::string str() const throw()
  {
    return std::string("sequence<")+itemType_->str()+","+
      xju::format::int_(maxSize_)+">";
  }
private:
  std::shared_ptr<TypeCode> itemType_;
  uint32_t maxSize_;
  
  friend bool operator==(SequenceTypeCode const& a,
                         SequenceTypeCode const& b) throw()
  {
    return a.maxSize_==b.maxSize_ &&
      a.itemType_->equals(*b.itemType_);
  }
};

  
class StructTypeCode : public TypeCode
{
public:
  StructTypeCode(std::string repoId,
                 std::string name,
                 std::vector<std::pair<std::string, std::shared_ptr<TypeCode> > > memberNamesAndTypes):
      repoId_(repoId),
      name_(name),
      memberNamesAndTypes_(memberNamesAndTypes)
  {
  }
  typedef std::vector<std::pair<std::string, std::shared_ptr<TypeCode> > > Members;
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    for(auto nameAndType : memberNamesAndTypes_) {
      nameAndType.second->copyValue(from,to);
    }
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::STRUCT, s);

    EncapsulationCdrStream es;
    cxy::cdr<std::string>::marshal(repoId_,*es);
    cxy::cdr<std::string>::marshal(name_,*es);
    cxy::cdr<uint32_t>::marshal(memberNamesAndTypes_.size(),*es);
    for(auto nameAndType : memberNamesAndTypes_) {
      cxy::cdr<std::string>::marshal(nameAndType.first,*es);
      nameAndType.second->marshal(*es);
    }

    cxy::cdr<EncapsulationCdrStream>::marshal(es,s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    StructTypeCode const* b_(dynamic_cast<StructTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    StructTypeCode const& b_(static_cast<StructTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  Members memberNamesAndTypes_;
  
  friend bool operator==(StructTypeCode const& a,
                         StructTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};

class UnionTypeCode : public TypeCode
{
public:
  typedef std::tuple<MemCdrStream,std::string,std::shared_ptr<TypeCode>> Case;
  UnionTypeCode(std::string repoId,
                std::string name,
                std::shared_ptr<TypeCode> const& descriminantType,
                std::vector<Case> const& cases,
                xju::Optional<uint32_t> const& indexOfDefaultCase) throw():
      repoId_(repoId),
      name_(name),
      descriminantType_(descriminantType),
      cases_(cases),
      indexOfDefaultCase_(indexOfDefaultCase)
  {
  }
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    MemCdrStream d;
    descriminantType_->copyValue(from,*d);
    descriminantType_->copyValue(*d,to);
    auto i=cases_.begin();
    for(; i!=cases_.end();++i){
      // default case could be anywhere in the sequence, we have to ignore it
      // until we've checked all the other cases... stupid encoding really
      if (indexOfDefaultCase_==xju::Optional<uint32_t>(i-cases_.begin())){
        continue;
      }
      if(std::get<0>(*i)==d){
        break;
      }
    }
    if (i!=cases_.end()){
      std::get<2>(*i)->copyValue(from,to);
    }
    // only now can we check the default case (if there is one)
    else if (indexOfDefaultCase_.valid()){
      std::get<2>(cases_[indexOfDefaultCase_.value()])->copyValue(from,to);
    }
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::UNION, s);

    EncapsulationCdrStream es;
    cxy::cdr<std::string>::marshal(repoId_,*es);
    cxy::cdr<std::string>::marshal(name_,*es);
    descriminantType_->marshal(*es);
    cxy::cdr<int32_t>::marshal(
      indexOfDefaultCase_.valid()?indexOfDefaultCase_.value():(int32_t)-1,
      *es);
    cxy::cdr<uint32_t>::marshal(cases_.size(),*es);
    for(auto c: cases_){
      descriminantType_->copyValue(*std::get<0>(c),*es);
      cxy::cdr<std::string>::marshal(std::get<1>(c),*es);
      std::get<2>(c)->marshal(*es);
    }

    cxy::cdr<EncapsulationCdrStream>::marshal(es,s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    UnionTypeCode const* b_(dynamic_cast<UnionTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    UnionTypeCode const& b_(static_cast<UnionTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  std::shared_ptr<TypeCode> descriminantType_;
  std::vector<Case> cases_;
  xju::Optional<uint32_t> indexOfDefaultCase_; //if valid, < cases_.size()
  
  friend bool operator==(UnionTypeCode const& a,
                         UnionTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};

class StringTypeCode : public TypeCode
{
public:
  explicit StringTypeCode(uint32_t maxSize):
      maxSize_(maxSize)
  {
  }
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    // deliberately don't check max size
    cxy::cdr<std::string>::marshal(
      cxy::cdr<std::string>::unmarshalFrom(from),
      to);
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::STRING, s);
    cxy::cdr<uint32_t>::marshal(maxSize_,s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    StringTypeCode const* b_(dynamic_cast<StringTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    StringTypeCode const& a_(static_cast<StringTypeCode const&>(*this));
    StringTypeCode const& b_(static_cast<StringTypeCode const&>(b));
    return a_.maxSize_ < b_.maxSize_;
  }
  virtual std::string str() const throw()
  {
    return std::string("std::string");
  }
private:
  uint32_t maxSize_;
  
  friend bool operator==(StringTypeCode const& a,
                         StringTypeCode const& b) throw()
  {
    return a.maxSize_==b.maxSize_;
  }
};


class AnyTypeCode : public TypeCode
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    std::shared_ptr<cxy::TypeCode> const t(
      cdr<std::shared_ptr<cxy::TypeCode> >::unmarshalFrom(from));
    t->marshal(to);
    t->copyValue(from, to);
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::ANY, s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    AnyTypeCode const* b_(dynamic_cast<AnyTypeCode const*>(&b));
    return b_;
  }
  virtual bool lessThan(TypeCode const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    return false;
  }
  virtual std::string str() const throw()
  {
    return "any";
  }
};


// TypeCodeOf provides a generic way of getting the TypeCode subclass
// for any type including plain old types. (Only predefined types have
// typecodes, user defined types use their underlying type's TypeCode, e.g.
// for IDL "struct X {};" the typecode is StructTypeCode
//
template<class T>
struct TypeCodeOf
{
private:
  static std::shared_ptr<TypeCode> create() throw(std::bad_alloc); //not implemented - must specialise class to provide implementations
};
  
template<>
struct TypeCodeOf<int16_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<int16_t,cxy::TypeKind::SHORT>);
}
};
  
template<>
struct TypeCodeOf<int32_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<int32_t,cxy::TypeKind::LONG>);
}
};
  
template<>
struct TypeCodeOf<int64_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<int64_t,cxy::TypeKind::LONGLONG>);
}
};
  
template<>
struct TypeCodeOf<uint16_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<uint16_t,cxy::TypeKind::USHORT>);
}
};
  
template<>
struct TypeCodeOf<uint32_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<uint32_t,cxy::TypeKind::ULONG>);
}
};
  
template<>
struct TypeCodeOf<uint64_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<uint64_t,cxy::TypeKind::ULONGLONG>);
}
};
  
template<>
struct TypeCodeOf<float>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<float,cxy::TypeKind::FLOAT>);
}
};
  
template<>
struct TypeCodeOf<double>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<double,cxy::TypeKind::DOUBLE>);
}
};
  
template<>
struct TypeCodeOf<long double>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<long double,cxy::TypeKind::LONGDOUBLE>);
}
};
  
template<>
struct TypeCodeOf<char>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<char,cxy::TypeKind::CHAR>);
}
};
  
template<>
struct TypeCodeOf<bool>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<bool,cxy::TypeKind::BOOLEAN>);
}
};
  
template<>
struct TypeCodeOf<uint8_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<uint8_t,cxy::TypeKind::OCTET>);
}
};
  
template<>
struct TypeCodeOf<char32_t>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new BasicTypeCode<char32_t,cxy::TypeKind::WCHAR>);
}
};
  
template<class T>
struct TypeCodeOf<std::vector<T> >
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new SequenceTypeCode(TypeCodeOf<T>::create(),0));
}
};

template<>
struct TypeCodeOf<std::string>
{
static std::shared_ptr<TypeCode> create() throw(std::bad_alloc)
{
  return std::shared_ptr<TypeCode>(
    new StringTypeCode(0));
}
};
  
// TypeCodeOf for structures is defined in code generated by cxyany.py backend


template<>
class cdr< std::shared_ptr<TypeCode> >
{
public:
  static std::shared_ptr<TypeCode> unmarshalFrom(cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  CORBA::SystemException,
  //  omni::giopStream::CommFailure
  //  )
  {
    uint32_t k(cxy::cdr<uint32_t>::unmarshalFrom(s));
    switch(static_cast<cxy::TypeKind>(k)) {
    case cxy::TypeKind::SHORT:
      return TypeCodeOf<int16_t>::create();
    case cxy::TypeKind::LONG:
      return TypeCodeOf<int32_t>::create();
    case cxy::TypeKind::LONGLONG:
      return TypeCodeOf<int64_t>::create();
    case cxy::TypeKind::USHORT:
      return TypeCodeOf<uint16_t>::create();
    case cxy::TypeKind::ULONG:
      return TypeCodeOf<uint32_t>::create();
    case cxy::TypeKind::ULONGLONG:
      return TypeCodeOf<uint64_t>::create();
    case cxy::TypeKind::FLOAT:
      return TypeCodeOf<float>::create();
    case cxy::TypeKind::DOUBLE:
      return TypeCodeOf<double>::create();
    case cxy::TypeKind::LONGDOUBLE:
      return TypeCodeOf<long double>::create();
    case cxy::TypeKind::BOOLEAN:
      return TypeCodeOf<bool>::create();
    case cxy::TypeKind::CHAR:
      return TypeCodeOf<char>::create();
    case cxy::TypeKind::OCTET:
      return TypeCodeOf<uint8_t>::create();
    case cxy::TypeKind::WCHAR:
      return TypeCodeOf<char32_t>::create();
    case cxy::TypeKind::ANY:
      return std::shared_ptr<TypeCode>(new AnyTypeCode);
    case cxy::TypeKind::STRING:
    {
      auto const maxSize(cdr<uint32_t>::unmarshalFrom(s));
      return std::shared_ptr<TypeCode>(new StringTypeCode(maxSize));
    }
    case cxy::TypeKind::SEQUENCE:
    {
      EncapsulationCdrStream es(s);
      auto const t(cdr< std::shared_ptr<TypeCode> >::unmarshalFrom(*es));
      auto const maxSize(cdr<uint32_t>::unmarshalFrom(*es));
      return std::shared_ptr<TypeCode>(new SequenceTypeCode(t,maxSize));
    }
    case cxy::TypeKind::STRUCT:
    {
      EncapsulationCdrStream es(s);
      auto const repoId(cdr<std::string>::unmarshalFrom(*es));
      auto const name(cdr<std::string>::unmarshalFrom(*es));
      auto const numberOfMembers(cdr<uint32_t>::unmarshalFrom(*es));
      StructTypeCode::Members members;
      for(auto i=0; i!=numberOfMembers; ++i) {
        auto name(cdr<std::string>::unmarshalFrom(*es));
        auto const t(cdr< std::shared_ptr<TypeCode> >::unmarshalFrom(*es));
        members.push_back(std::make_pair(name,t));
      }
      return std::shared_ptr<TypeCode>(new StructTypeCode(
                                         repoId,
                                         name,
                                         members));
    }
    default:
      std::ostringstream s;
      s << "unimplemented type kind " << k;
      throw CORBA::MARSHAL(26,CORBA::COMPLETED_NO);
    }
  }

  static void marshal(std::shared_ptr<TypeCode const> x, cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    x->marshal(s);
  }
};
  
}
