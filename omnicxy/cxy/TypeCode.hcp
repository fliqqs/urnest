// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <cxy/cdr.hh>
#include <cxy/TypeKind.hh>

#include <omniORB4/CORBA.h> //impl
#include <omniORB4/cdrStream.h> //impl
#include <xju/format.hh>//impl
#include <cxy/EncapsulationCdrStream.hh>//impl
#include <memory>

class cdrStream;

namespace cxy
{
class TypeCode
{
public:
  virtual ~TypeCode() throw(){}

  virtual void copyValue(cdrStream& from, cdrStream& to) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  virtual void marshal(cdrStream& s) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  virtual bool equals(TypeCode const& b) const throw() = 0;

  virtual std::string str() const throw() = 0;
};
std::ostream& operator<<(std::ostream& s, TypeCode const& x) throw()
{
  return s << x.str();
}

template<class T>
class TypeCodeOf : public TypeCode // must specialise
{
};

template<class T>
std::shared_ptr<TypeCode> typeCodeOf(T const&) throw()
{
  return std::shared_ptr<TypeCode>(new TypeCodeOf<T>);
}

template<>  
class TypeCodeOf<int16_t> : public TypeCode
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    cxy::cdr<int16_t>::marshal(
      cxy::cdr<int16_t>::unmarshalFrom(from),
      to);
  }

  virtual void marshal(cdrStream& s) const
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::SHORT, s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    TypeCodeOf const* b_(dynamic_cast<TypeCodeOf const*>(&b));
    return b_;
  }
  virtual std::string str() const throw()
  {
    return "int16_t";
  }
};

class SequenceTypeCode : public TypeCode
{
public:
  SequenceTypeCode(std::shared_ptr<TypeCode> itemType,
                   uint32_t maxSize):
      itemType_(itemType),
      maxSize_(maxSize)
  {
  }
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    uint32_t const size(
      cxy::cdr<uint32_t>::unmarshalFrom(from));
    // deliberately don't check max size
    for(uint32_t i=0; i != size; ++i) {
      itemType_->copyValue(from,to);
    }
  }

  virtual void marshal(cdrStream& s) const
  {
    EncapsulationCdrStream es;
    itemType_->marshal(*es);
    cxy::cdr<uint32_t>::marshal(maxSize_,*es);

    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::SEQUENCE, s);
    cxy::cdr<EncapsulationCdrStream>::marshal(es,s);
  }
  
  virtual bool equals(TypeCode const& b) const throw()
  {
    SequenceTypeCode const* b_(dynamic_cast<SequenceTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual std::string str() const throw()
  {
    return std::string("sequence<")+itemType_->str()+","+
      xju::format::int_(maxSize_)+">";
  }
private:
  std::shared_ptr<TypeCode> itemType_;
  uint32_t maxSize_;
  
  friend bool operator==(SequenceTypeCode const& a,
                         SequenceTypeCode const& b) throw()
  {
    return a.maxSize_==b.maxSize_ &&
      a.itemType_->equals(*b.itemType_);
  }
};

  
template<class T>  
class TypeCodeOf<std::vector<T> > : public SequenceTypeCode
{
public:
  TypeCodeOf<std::vector<T> >() throw():
      SequenceTypeCode(std::shared_ptr<TypeCodeOf<T> >(
                         new TypeCodeOf<T>),
                       0) {
  }
  virtual bool equals(TypeCode const& b) const throw()
  {
    TypeCodeOf const* b_(dynamic_cast<TypeCodeOf const*>(&b));
    return b_ || SequenceTypeCode::equals(b);
  }

  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    cxy::cdr<std::vector<T> >::marshal(
      cxy::cdr<std::vector<T> >::unmarshalFrom(from),
      to);
  }

};

template<>
class cdr< std::shared_ptr<TypeCode> >
{
public:
  static std::shared_ptr<TypeCode> unmarshalFrom(cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  CORBA::SystemException,
  //  omni::giopStream::CommFailure
  //  )
  {
    uint32_t k(cxy::cdr<uint32_t>::unmarshalFrom(s));
    switch(static_cast<cxy::TypeKind>(k)) {
    case cxy::TypeKind::SHORT:
      return std::shared_ptr<TypeCode>(new TypeCodeOf<int16_t>);
    case cxy::TypeKind::SEQUENCE:
    {
      EncapsulationCdrStream es(s);
      auto const t(cdr< std::shared_ptr<TypeCode> >::unmarshalFrom(*es));
      auto const maxSize(cdr<uint32_t>::unmarshalFrom(*es));
      return std::shared_ptr<TypeCode>(new SequenceTypeCode(t,maxSize));
    }
    default:
      std::ostringstream s;
      s << "unimplemented type kind " << k;
      throw CORBA::MARSHAL(26,CORBA::COMPLETED_NO);
    }
  }

  static void marshal(std::shared_ptr<TypeCode const> x, cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    x->marshal(s);
  }
};
  
bool operator==(TypeCode const& a, TypeCode const& b) throw()
{
  return a.equals(b);
}
  
}
