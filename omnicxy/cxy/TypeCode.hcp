// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <cxy/cdr.hh>
#include <cxy/TypeKind.hh>
#include <cxy/TypeTag.hh>

#include <omniORB4/CORBA.h> //impl
#include <omniORB4/cdrStream.h> //impl
#include <xju/format.hh>//impl
#include <cxy/EncapsulationCdrStream.hh>
#include <memory>
#include <vector>
#include <typeinfo>
#include <typeindex>
#include <cxy/MemCdrStream.hh>
#include <xju/Optional.hh>
#include <map>
#include <functional>

class cdrStream;

namespace cxy
{

// CORBA 3.3 9.3.5.1 TypeCode
//
// TypeCode describes a type well enough to marshal and unmarshal
// objects of that type without their IDL definitions.
//
class TypeCode_
{
public:
  class OstreamIf
  {
  public:
    virtual ~OstreamIf() throw() {}
    class Ref
    {
    public:
      //pre: x will outlive this
      Ref(TypeCode_ const& x) throw():
          x_(&x)
      {
      }
      TypeCode_ const* x_;
      friend bool operator<(Ref const& x, Ref const& y) throw(){
        return (*(x.x_)) < (*(y.x_));
      }
    };
    struct StreamPosTag{};
    typedef xju::Int<StreamPosTag,uint32_t> StreamPos;
    typedef std::map<Ref,StreamPos> Index;
    virtual Index& index() throw()=0;
    virtual StreamPos currentPosition() const throw()=0;
    virtual cdrStream& s() throw()=0;
  };
  
  virtual ~TypeCode_() throw(){}

  virtual void copyValue(cdrStream& from, cdrStream& to) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  virtual void marshal_(TypeCode_::OstreamIf& s) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  = 0;

  void marshal(TypeCode_::OstreamIf& s) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    if (&derefed()!=this)
    {
      //reference, the real type should already be marhalled
      auto const i(s.index().find(OstreamIf::Ref(derefed())));
      xju::assert_not_equal(i,s.index().end());
      //reference previous marshal of this type
      cxy::cdr<uint32_t>::marshal((uint32_t)0xffffffff, s.s());
      cxy::cdr<int32_t>::marshal(
        -(s.currentPosition()-(*i).second).value(),
        s.s());
    }
    else{
      auto const i(s.index().insert(std::make_pair(OstreamIf::Ref(*this),
                                                   s.currentPosition())));
      xju::assert_equal(i.second,true); //we should not be nested in outselves
      marshal_(s);
    }
  }
  virtual bool equals(TypeCode_ const& b) const throw() = 0;

  //pre: typeid(*this)==typeid(b)
  virtual bool lessThan(TypeCode_ const& b) const throw() = 0;
  
  virtual std::string str() const throw() = 0;

  virtual TypeCode_ const& derefed() const throw(){
    return *this;
  }
  friend bool operator==(TypeCode_ const& a, TypeCode_ const& b) throw()
  {
    return a.equals(b);
  }
  friend bool operator<(TypeCode_ const& a, TypeCode_ const& b) throw()
  {
    if (std::type_index(typeid(a.derefed()))<
        std::type_index(typeid(b.derefed()))){
      return true;
    }
    if (std::type_index(typeid(b.derefed()))<
        std::type_index(typeid(a.derefed()))){
      return false;
    }
    return a.derefed().lessThan(b.derefed());
  }
};
std::ostream& operator<<(std::ostream& s, TypeCode_ const& x) throw()
{
  return s << x.str();
}

namespace
{

class TypeCodeOstream : public TypeCode_::OstreamIf
{
public:
  ~TypeCodeOstream() throw(){}

  //pre: s will outlive this
  explicit TypeCodeOstream(cdrStream& s) throw():
      s_(s)
  {
  }
  virtual TypeCode_::OstreamIf::Index& index() throw() override
  {
    return index_;
  }
  virtual TypeCode_::OstreamIf::StreamPos currentPosition() const throw()
    override
  {
    return StreamPos(s_.currentOutputPtr());
  }
  virtual cdrStream& s() throw() override
  {
    return s_;
  }
  
private:
  TypeCode_::OstreamIf::Index index_;
  cdrStream& s_;
};
class EncapsulationTypeCodeOstream : public TypeCode_::OstreamIf
{
public:
  ~EncapsulationTypeCodeOstream() throw(){}
  // pre: outer will outlive this
  explicit EncapsulationTypeCodeOstream(TypeCode_::OstreamIf& outer) throw():
      outer_(outer),
      outerPos_(outer.currentPosition()),
      sInitialPos_((*s_).currentOutputPtr())
  {
  }
  virtual TypeCode_::OstreamIf::Index& index() throw() override
  {
    return outer_.index();
  }
  virtual TypeCode_::OstreamIf::StreamPos currentPosition() const throw()
    override
  {
    // we assume sInitialPos is after the byte-order byte, and
    // that outer pos is at the point where our encapsulation length
    // will be placed, so that outerPos_+1+4 will be the location of
    // the first encapsulated object
    return outerPos_+StreamPos(5)+
      (StreamPos((*s_).currentOutputPtr())-sInitialPos_);
  }
  virtual cdrStream& s() throw() override
  {
    return *s_;
  }
  void marshal()
  {
    //check nothing has gone into outer stream since we were constructed
    xju::assert_equal(outer_.currentPosition(),outerPos_);
    cdr<EncapsulationCdrStream>::marshal(s_,outer_.s());
    //did we get it right?
    xju::assert_equal(outer_.currentPosition(),currentPosition());
  }
private:
  TypeCode_::OstreamIf& outer_;
  TypeCode_::OstreamIf::StreamPos const outerPos_;
  cxy::EncapsulationCdrStream s_;
  TypeCode_::OstreamIf::StreamPos const sInitialPos_;
};

}

class TypeCode
{
public:
  explicit TypeCode(std::shared_ptr<TypeCode_ const> value) throw():
      value_(value)
  {
  }
  TypeCode_ const& operator*() const throw(){
    return *value_;
  }
  TypeCode_ const* operator->() const throw(){
    return value_.operator->();
  }
private:
  std::shared_ptr<TypeCode_ const> value_;

  friend bool operator==(TypeCode const& x, TypeCode const& y) throw(){
    return *x.value_==*y.value_;
  }
  friend bool operator!=(TypeCode const& x, TypeCode const& y) throw(){
    return !(x==y);
  }
  friend bool operator<(TypeCode const& x, TypeCode const& y) throw(){
    return *x.value_<*y.value_;
  }
  friend bool operator<=(TypeCode const& x, TypeCode const& y) throw(){
    return (x<y)||(x==y);
  }
  friend bool operator>(TypeCode const& x, TypeCode const& y) throw(){
    return (y<x);
  }
  friend bool operator>=(TypeCode const& x, TypeCode const& y) throw(){
    return (y<=x);
  }
  friend std::ostream& operator<<(std::ostream& s, TypeCode const& x) throw(){
    return s << (*x.value_);
  }
};

//typecode class for void
class VoidTypeCode : public TypeCode_
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)cxy::TypeKind::VOID, s.s());
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    VoidTypeCode const* b_(dynamic_cast<VoidTypeCode const*>(&b));
    return b_;
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    return false;
  }
  virtual std::string str() const throw()
  {
    return "void";
  }
};

//typecode class for eg CORBA::Short (ie int16_t)
template<class BasicType, cxy::TypeKind typeKind>
class BasicTypeCode : public TypeCode_
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    cxy::cdr<BasicType>::marshal(
      cxy::cdr<BasicType>::unmarshalFrom(from),
      to);
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)typeKind, s.s());
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    BasicTypeCode const* b_(dynamic_cast<BasicTypeCode const*>(&b));
    return b_;
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    return false;
  }
  virtual std::string str() const throw()
  {
    return typeid(BasicType).name();
  }
};

class SequenceTypeCode : public TypeCode_
{
public:
  SequenceTypeCode(TypeCode const& itemType,
                   uint32_t maxSize):
      itemType_(itemType),
      maxSize_(maxSize)
  {
  }
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    uint32_t const size(
      cxy::cdr<uint32_t>::unmarshalFrom(from));
    cxy::cdr<uint32_t>::marshal(size,to);
    // deliberately don't check max size
    for(uint32_t i=0; i != size; ++i) {
      itemType_->copyValue(from,to);
    }
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::SEQUENCE, s.s());

    EncapsulationTypeCodeOstream es(s);
    itemType_->marshal(es);
    cxy::cdr<uint32_t>::marshal(maxSize_,es.s());

    es.marshal();
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    SequenceTypeCode const* b_(dynamic_cast<SequenceTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    SequenceTypeCode const& a_(static_cast<SequenceTypeCode const&>(*this));
    SequenceTypeCode const& b_(static_cast<SequenceTypeCode const&>(b));
    if (*a_.itemType_ < *b_.itemType_){
      return true;
    }
    if (*b_.itemType_ < *a_.itemType_){
      return false;
    }
    return a_.maxSize_ < b_.maxSize_;
  }
  virtual std::string str() const throw()
  {
    return std::string("sequence<")+itemType_->str()+","+
      xju::format::int_(maxSize_)+">";
  }
private:
  TypeCode itemType_;
  uint32_t maxSize_;
  
  friend bool operator==(SequenceTypeCode const& a,
                         SequenceTypeCode const& b) throw()
  {
    return a.maxSize_==b.maxSize_ &&
      a.itemType_->equals(*b.itemType_);
  }
};

  
class StructTypeCode : public TypeCode_
{
public:
  StructTypeCode(std::string repoId,
                 std::string name,
                 std::vector<std::pair<std::string, TypeCode > > memberNamesAndTypes):
      repoId_(repoId),
      name_(name),
      memberNamesAndTypes_(memberNamesAndTypes)
  {
  }
  typedef std::vector<std::pair<std::string, TypeCode > > Members;
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    for(auto nameAndType : memberNamesAndTypes_) {
      nameAndType.second->copyValue(from,to);
    }
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::STRUCT, s.s());

    EncapsulationTypeCodeOstream es(s);
    cxy::cdr<std::string>::marshal(repoId_,es.s());
    cxy::cdr<std::string>::marshal(name_,es.s());
    cxy::cdr<uint32_t>::marshal(memberNamesAndTypes_.size(),es.s());
    for(auto nameAndType : memberNamesAndTypes_) {
      cxy::cdr<std::string>::marshal(nameAndType.first,es.s());
      nameAndType.second->marshal(es);
    }
    es.marshal();
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    StructTypeCode const* b_(dynamic_cast<StructTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    StructTypeCode const& b_(static_cast<StructTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  Members memberNamesAndTypes_;
  
  friend bool operator==(StructTypeCode const& a,
                         StructTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};

class UnionTypeCode : public TypeCode_
{
public:
  typedef std::tuple<MemCdrStream,std::string,TypeCode> Case;
  UnionTypeCode(std::string repoId,
                std::string name,
                TypeCode const& descriminantType,
                std::vector<Case> const& cases,
                xju::Optional<uint32_t> const& indexOfDefaultCase) throw():
      repoId_(repoId),
      name_(name),
      descriminantType_(descriminantType),
      cases_(cases),
      indexOfDefaultCase_(indexOfDefaultCase)
  {
  }
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    MemCdrStream d;
    descriminantType_->copyValue(from,*d);
    descriminantType_->copyValue(*d,to);
    auto i=cases_.begin();
    for(; i!=cases_.end();++i){
      // default case could be anywhere in the sequence, we have to ignore it
      // until we've checked all the other cases... stupid encoding really
      if (indexOfDefaultCase_==xju::Optional<uint32_t>(i-cases_.begin())){
        continue;
      }
      if(std::get<0>(*i)==d){
        break;
      }
    }
    if (i!=cases_.end()){
      std::get<2>(*i)->copyValue(from,to);
    }
    // only now can we check the default case (if there is one)
    else if (indexOfDefaultCase_.valid()){
      std::get<2>(cases_[indexOfDefaultCase_.value()])->copyValue(from,to);
    }
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::UNION, s.s());

    EncapsulationTypeCodeOstream es(s);
    cxy::cdr<std::string>::marshal(repoId_,es.s());
    cxy::cdr<std::string>::marshal(name_,es.s());
    descriminantType_->marshal(es);
    cxy::cdr<int32_t>::marshal(
      indexOfDefaultCase_.valid()?indexOfDefaultCase_.value():(int32_t)-1,
      es.s());
    cxy::cdr<uint32_t>::marshal(cases_.size(),es.s());
    for(auto c: cases_){
      descriminantType_->copyValue(*std::get<0>(c),es.s());
      cxy::cdr<std::string>::marshal(std::get<1>(c),es.s());
      std::get<2>(c)->marshal(es);
    }
    es.marshal();
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    UnionTypeCode const* b_(dynamic_cast<UnionTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    UnionTypeCode const& b_(static_cast<UnionTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  TypeCode descriminantType_;
  std::vector<Case> cases_;
  xju::Optional<uint32_t> indexOfDefaultCase_; //if valid, < cases_.size()
  
  friend bool operator==(UnionTypeCode const& a,
                         UnionTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};

class ExceptionTypeCode : public TypeCode_
{
public:
  ExceptionTypeCode(
    std::string repoId,
    std::string name,
    std::vector<std::pair<std::string, TypeCode > > memberNamesAndTypes)
      throw():
      repoId_(repoId),
      name_(name),
      memberNamesAndTypes_(memberNamesAndTypes)
  {
  }
    
  typedef std::vector<std::pair<std::string, TypeCode > > Members;
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const override
  {
    for(auto nameAndType : memberNamesAndTypes_) {
      nameAndType.second->copyValue(from,to);
    }
  }    

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::EXCEPT, s.s());

    EncapsulationTypeCodeOstream es(s);
    cxy::cdr<std::string>::marshal(repoId_,es.s());
    cxy::cdr<std::string>::marshal(name_,es.s());
    cxy::cdr<uint32_t>::marshal(memberNamesAndTypes_.size(),es.s());
    for(auto nameAndType : memberNamesAndTypes_) {
      cxy::cdr<std::string>::marshal(nameAndType.first,es.s());
      nameAndType.second->marshal(es);
    }
    es.marshal();
  }  
  virtual bool equals(TypeCode_ const& b) const throw() override
  {
    ExceptionTypeCode const* b_(dynamic_cast<ExceptionTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    ExceptionTypeCode const& b_(static_cast<ExceptionTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  Members memberNamesAndTypes_;
  
  friend bool operator==(ExceptionTypeCode const& a,
                         ExceptionTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};

class StringTypeCode : public TypeCode_
{
public:
  explicit StringTypeCode(uint32_t maxSize):
      maxSize_(maxSize)
  {
  }
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    // deliberately don't check max size
    cxy::cdr<std::string>::marshal(
      cxy::cdr<std::string>::unmarshalFrom(from),
      to);
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::STRING, s.s());
    cxy::cdr<uint32_t>::marshal(maxSize_,s.s());
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    StringTypeCode const* b_(dynamic_cast<StringTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    StringTypeCode const& a_(static_cast<StringTypeCode const&>(*this));
    StringTypeCode const& b_(static_cast<StringTypeCode const&>(b));
    return a_.maxSize_ < b_.maxSize_;
  }
  virtual std::string str() const throw()
  {
    return std::string("std::string");
  }
private:
  uint32_t maxSize_;
  
  friend bool operator==(StringTypeCode const& a,
                         StringTypeCode const& b) throw()
  {
    return a.maxSize_==b.maxSize_;
  }
};


class EnumTypeCode : public TypeCode_
{
public:
  EnumTypeCode(std::string repoId,
               std::string name,
               std::vector<std::string> values):
      repoId_(repoId),
      name_(name),
      values_(values)
  {
  }
  typedef std::vector<std::string> Values;
  
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    cxy::cdr<int32_t>::marshal(
      cxy::cdr<int32_t>::unmarshalFrom(from),
      to);
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::ENUM, s.s());

    EncapsulationTypeCodeOstream es(s);
    cxy::cdr<std::string>::marshal(repoId_,es.s());
    cxy::cdr<std::string>::marshal(name_,es.s());
    cxy::cdr<uint32_t>::marshal(values_.size(),es.s());
    for(auto value : values_) {
      cxy::cdr<std::string>::marshal(value,es.s());
    }
    es.marshal();
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    EnumTypeCode const* b_(dynamic_cast<EnumTypeCode const*>(&b));
    return b_ && (*b_==*this);
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    EnumTypeCode const& b_(static_cast<EnumTypeCode const&>(b));
    return repoId_<b_.repoId_;
  }
  virtual std::string str() const throw()
  {
    return repoId_;
  }
private:
  std::string repoId_;
  std::string name_;
  Values values_;
  
  friend bool operator==(EnumTypeCode const& a,
                         EnumTypeCode const& b) throw()
  {
    return a.repoId_==b.repoId_;
  }
};


class AnyTypeCode : public TypeCode_
{
public:
  virtual void copyValue(cdrStream& from, cdrStream& to) const
  {
    TypeCode const t(
      cdr<TypeCode>::unmarshalFrom(from));
    ::cxy::cdr< ::cxy::TypeCode >::marshal(t,to);
    t->copyValue(from, to);
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  {
    cxy::cdr<uint32_t>::marshal((uint32_t)TypeKind::ANY, s.s());
  }
  
  virtual bool equals(TypeCode_ const& b) const throw()
  {
    AnyTypeCode const* b_(dynamic_cast<AnyTypeCode const*>(&b));
    return b_;
  }
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    xju::assert_equal(typeid(*this),typeid(b));
    return false;
  }
  virtual std::string str() const throw()
  {
    return "any";
  }
};

class ReferenceTypeCode_ : public TypeCode_
{
public:
  ReferenceTypeCode_() throw():
      p_(0)
  {
  }
  explicit ReferenceTypeCode_(TypeCode_ const& p) throw():
      p_(&p)
  {
  }
  virtual ~ReferenceTypeCode_() throw(){}

  virtual void copyValue(cdrStream& from, cdrStream& to) const
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    return p_->copyValue(from,to);
  }

  virtual void marshal_(TypeCode_::OstreamIf& s) const override
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    xju::assert_never_reached(); //because the referrenced TypeCode should already be in s.index() and hence TypeCode_::marshal() should have taken care of it
  }

  virtual bool equals(TypeCode_ const& b) const throw()
  {
    return p_->equals(b);
  }

  //pre: typeid(*this)==typeid(b)
  virtual bool lessThan(TypeCode_ const& b) const throw()
  {
    return (*p_)<b;
  }
  
  virtual std::string str() const throw()
  {
    return p_->str();
  }

  void referTo(TypeCode_ const& p) throw()
  {
    p_=&p;
  }

  virtual TypeCode_ const& derefed() const throw() override
  {
    return p_->derefed();
  }
private:
  TypeCode_ const* p_;
};

typedef std::map<std::type_info const*,std::vector<std::reference_wrapper<ReferenceTypeCode_> > > TypeCodeRefIndex;

// TypeCodeOf provides a generic way of getting the TypeCode subclass
// for any type including plain old types. (Only predefined types have
// typecodes, user defined types use their underlying type's TypeCode, e.g.
// for IDL "struct X {};" the typecode is StructTypeCode
//
template<class T>
struct TypeCodeOf
{
private:
  static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc); //not implemented - must specialise class to provide implementations
};

template<class T>
TypeCode createTypeCodeOf(TypeCodeRefIndex& index) throw(std::bad_alloc){
  auto const i(index.insert(TypeCodeRefIndex::value_type(&typeid(T),{})));
  if (i.second){
    auto const result(TypeCodeOf<T>::create(index));
    for(auto x: (*i.first).second){
      x.get().referTo(*result);
    }
    index.erase(i.first);
    return result;
  }
  else{
    std::shared_ptr<ReferenceTypeCode_> result(new ReferenceTypeCode_);
    (*i.first).second.push_back(std::ref(*result));
    return TypeCode(result);
  }
}

template<class T>
TypeCode createTypeCodeOf() throw(std::bad_alloc){
  TypeCodeRefIndex index;
  return createTypeCodeOf<T>(index);
}

template<>
struct TypeCodeOf<void>
{
static TypeCode create(TypeCodeRefIndex& index) throw(
  std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new VoidTypeCode));
}
};
  
template<>
struct TypeCodeOf<int16_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(
  std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<int16_t,cxy::TypeKind::SHORT>));
}
};
  
template<>
struct TypeCodeOf<int32_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<int32_t,cxy::TypeKind::LONG>));
}
};
  
template<>
struct TypeCodeOf<int64_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<int64_t,cxy::TypeKind::LONGLONG>));
}
};
  
template<>
struct TypeCodeOf<uint16_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<uint16_t,cxy::TypeKind::USHORT>));
}
};
  
template<>
struct TypeCodeOf<uint32_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<uint32_t,cxy::TypeKind::ULONG>));
}
};
  
template<>
struct TypeCodeOf<uint64_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<uint64_t,cxy::TypeKind::ULONGLONG>));
}
};
  
template<>
struct TypeCodeOf<float>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<float,cxy::TypeKind::FLOAT>));
}
};
  
template<>
struct TypeCodeOf<double>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<double,cxy::TypeKind::DOUBLE>));
}
};
  
template<>
struct TypeCodeOf<long double>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<long double,cxy::TypeKind::LONGDOUBLE>));
}
};
  
template<>
struct TypeCodeOf<char>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<char,cxy::TypeKind::CHAR>));
}
};
  
template<>
struct TypeCodeOf<bool>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<bool,cxy::TypeKind::BOOLEAN>));
}
};
  
template<>
struct TypeCodeOf<uint8_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<uint8_t,cxy::TypeKind::OCTET>));
}
};
  
template<>
struct TypeCodeOf<char32_t>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<char32_t,cxy::TypeKind::WCHAR>));
}
};
  
template<class T>
struct TypeCodeOf<std::vector<T> >
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new SequenceTypeCode(createTypeCodeOf<T>(index),0)));
}
};

template<>
struct TypeCodeOf<std::string>
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new StringTypeCode(0)));
}
};

template<>
struct TypeCodeOf< TypeCode >
{
static TypeCode create(TypeCodeRefIndex& index) throw(std::bad_alloc)
{
  return TypeCode(
    std::shared_ptr<TypeCode_>(
      new BasicTypeCode<TypeCode,cxy::TypeKind::TYPECODE>));
}
};
  
// TypeCodeOf for structures, unions, exceptionss defined in code generated
// by cxyany.py backend


namespace
{
class TypeCodeIstreamIf
{
public:
  virtual ~TypeCodeIstreamIf() throw() {}
  struct StreamPosTag{};
  typedef xju::Int<StreamPosTag,uint32_t> StreamPos;
  typedef std::vector<
    std::pair<
      StreamPos, //note ascending
      std::pair<
        TypeCode_ const*,
        std::vector<std::reference_wrapper<ReferenceTypeCode_> > > > > Index;
  virtual Index& index() throw()=0;
  virtual StreamPos currentPosition() const throw()=0;
  virtual cdrStream& s() throw()=0;
};
class TypeCodeIstream : public TypeCodeIstreamIf
{
public:
  //pre: s will outlive this
  explicit TypeCodeIstream(cdrStream& s) throw():
      s_(s)
  {
  }
  ~TypeCodeIstream() throw()
  {
    for(auto i(index_.begin()); i!=index_.end();++i){
      if ((*i).second.second.size()){
        xju::assert_not_equal((*i).second.first,(TypeCode_ const*)0);
        for(auto r: (*i).second.second){
          r.get().referTo(*(*i).second.first);
        }
      }
    }
  }

  virtual TypeCodeIstreamIf::Index& index() throw() override
  {
    return index_;
  }
  virtual TypeCodeIstreamIf::StreamPos currentPosition() const throw()
    override
  {
    return StreamPos(s_.currentInputPtr());
  }
  virtual cdrStream& s() throw() override
  {
    return s_;
  }
  
private:
  TypeCodeIstreamIf::Index index_;
  cdrStream& s_;
};
class EncapsulationTypeCodeIstream : public TypeCodeIstreamIf
{
public:
  ~EncapsulationTypeCodeIstream() throw(){}
  // pre: outer will outlive this
  explicit EncapsulationTypeCodeIstream(TypeCodeIstreamIf& outer) throw():
      outer_(outer),
      outerPos_(outer.currentPosition()),
      s_(outer.s()),
      sPos_((*s_).currentInputPtr())
  {
  }
  virtual TypeCodeIstreamIf::Index& index() throw() override
  {
    return outer_.index();
  }
  virtual TypeCodeIstreamIf::StreamPos currentPosition() const throw()
    override
  {
    // we assume sInitialPos is after the byte-order byte, and
    // that outer pos is at the point where our encapsulation length
    // was, so that outerPos_+1+4 will be the location of
    // the first encapsulated object
    return outerPos_+StreamPos(5)+
      (StreamPos((*s_).currentInputPtr())-sPos_);
  }
  virtual cdrStream& s() throw() override
  {
    return *s_;
  }
private:
  TypeCodeIstreamIf& outer_;
  TypeCodeIstreamIf::StreamPos const outerPos_;
  cxy::EncapsulationCdrStream s_;
  TypeCodeIstreamIf::StreamPos const sPos_;
};

TypeCode unmarshalTypeCodeFrom(TypeCodeIstreamIf& s);
TypeCode unmarshalTypeCodeFrom_(TypeCodeIstreamIf& s,
                                cxy::TypeKind const& k)
//to avoid needing CORBA.h in our .hh, exception specs are commented
//throw(
//  CORBA::SystemException,
//  omni::giopStream::CommFailure
//  )
{
  switch(k) {
  case cxy::TypeKind::VOID:
    return createTypeCodeOf<void>();
  case cxy::TypeKind::SHORT:
    return createTypeCodeOf<int16_t>();
  case cxy::TypeKind::LONG:
    return createTypeCodeOf<int32_t>();
  case cxy::TypeKind::LONGLONG:
    return createTypeCodeOf<int64_t>();
  case cxy::TypeKind::USHORT:
    return createTypeCodeOf<uint16_t>();
  case cxy::TypeKind::ULONG:
    return createTypeCodeOf<uint32_t>();
  case cxy::TypeKind::ULONGLONG:
    return createTypeCodeOf<uint64_t>();
  case cxy::TypeKind::FLOAT:
    return createTypeCodeOf<float>();
  case cxy::TypeKind::DOUBLE:
    return createTypeCodeOf<double>();
  case cxy::TypeKind::LONGDOUBLE:
    return createTypeCodeOf<long double>();
  case cxy::TypeKind::BOOLEAN:
    return createTypeCodeOf<bool>();
  case cxy::TypeKind::CHAR:
    return createTypeCodeOf<char>();
  case cxy::TypeKind::OCTET:
    return createTypeCodeOf<uint8_t>();
  case cxy::TypeKind::WCHAR:
    return createTypeCodeOf<char32_t>();
  case cxy::TypeKind::ANY:
    return TypeCode(
      std::shared_ptr<TypeCode_>(new AnyTypeCode));
  case cxy::TypeKind::STRING:
  {
    auto const maxSize(cdr<uint32_t>::unmarshalFrom(s.s()));
    return TypeCode(
      std::shared_ptr<TypeCode_>(new StringTypeCode(maxSize)));
  }
  case cxy::TypeKind::SEQUENCE:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const t(unmarshalTypeCodeFrom(es));
    auto const maxSize(cdr<uint32_t>::unmarshalFrom(es.s()));
    return TypeCode(
      std::shared_ptr<TypeCode_>(new SequenceTypeCode(t,maxSize)));
  }
  case cxy::TypeKind::STRUCT:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const repoId(cdr<std::string>::unmarshalFrom(es.s()));
    auto const name(cdr<std::string>::unmarshalFrom(es.s()));
    auto const numberOfMembers(cdr<uint32_t>::unmarshalFrom(es.s()));
    StructTypeCode::Members members;
    for(auto i=0; i!=numberOfMembers; ++i) {
      auto name(cdr<std::string>::unmarshalFrom(es.s()));
      auto const t(unmarshalTypeCodeFrom(es));
      members.push_back(std::make_pair(name,t));
    }
    return TypeCode(
      std::shared_ptr<TypeCode_>(new StructTypeCode(
                                   repoId,
                                   name,
                                   members)));
  }
  case cxy::TypeKind::EXCEPT:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const repoId(cdr<std::string>::unmarshalFrom(es.s()));
    auto const name(cdr<std::string>::unmarshalFrom(es.s()));
    auto const numberOfMembers(cdr<uint32_t>::unmarshalFrom(es.s()));
    StructTypeCode::Members members;
    for(auto i=0; i!=numberOfMembers; ++i) {
      auto name(cdr<std::string>::unmarshalFrom(es.s()));
      auto const t(unmarshalTypeCodeFrom(es));
      members.push_back(std::make_pair(name,t));
    }
    return TypeCode(
      std::shared_ptr<TypeCode_>(new ExceptionTypeCode(
                                   repoId,
                                   name,
                                   members)));
  }
  case cxy::TypeKind::UNION:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const repoId(cdr<std::string>::unmarshalFrom(es.s()));
    auto const name(cdr<std::string>::unmarshalFrom(es.s()));
    auto const descriminantType(
      unmarshalTypeCodeFrom(es));
    auto const defaultCaseUsed(cdr<int32_t>::unmarshalFrom(es.s()));
    xju::Optional<uint32_t> const indexOfDefaultCase(
      defaultCaseUsed<0?
      xju::Optional<uint32_t>():
      xju::Optional<uint32_t>(defaultCaseUsed));
    auto const numberOfCases(cdr<uint32_t>::unmarshalFrom(es.s()));
    std::vector<UnionTypeCode::Case> cases;
    for(auto i=0; i!=numberOfCases; ++i) {
      MemCdrStream value;
      descriminantType->copyValue(es.s(),*value);
      auto name(cdr<std::string>::unmarshalFrom(es.s()));
      auto const t(unmarshalTypeCodeFrom(es));
      cases.push_back(UnionTypeCode::Case(std::move(value),name,t));
    }
    return TypeCode(
      std::shared_ptr<TypeCode_>(new UnionTypeCode(
                                   repoId,
                                   name,
                                   descriminantType,
                                   cases,
                                   indexOfDefaultCase)));
  }
  case cxy::TypeKind::ENUM:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const repoId(cdr<std::string>::unmarshalFrom(es.s()));
    auto const name(cdr<std::string>::unmarshalFrom(es.s()));
    auto const numberOfValues(cdr<uint32_t>::unmarshalFrom(es.s()));
    EnumTypeCode::Values values;
    for(auto i=0; i!=numberOfValues; ++i) {
      auto name(cdr<std::string>::unmarshalFrom(es.s()));
      values.push_back(name);
    }
    return TypeCode(
      std::shared_ptr<TypeCode_>(new EnumTypeCode(
                                   repoId,
                                   name,
                                   values)));
  }
  case cxy::TypeKind::TYPECODE:
  {
    return createTypeCodeOf<TypeCode>();
  }
  case cxy::TypeKind::ALIAS:
  {
    cxy::EncapsulationTypeCodeIstream es(s);
    auto const repoId(cdr<std::string>::unmarshalFrom(es.s()));
    auto const name(cdr<std::string>::unmarshalFrom(es.s()));
    auto const t(unmarshalTypeCodeFrom(es));
    return t;
  }
  case cxy::TypeKind::REFERENCE:
  {
    //the offset in the cdr stream is relative to the start of the offset
    //i.e. the position before decoding the 4-byte offset
    TypeCodeIstreamIf::StreamPos const offset(
      // cdr encoding of offset is negative offset
      -cdr<int32_t>::unmarshalFrom(s.s())+4);
    TypeCodeIstreamIf::StreamPos currentPosition(s.currentPosition());
    TypeCodeIstreamIf::StreamPos const absolutePosition(
      currentPosition-offset);
    auto const i(std::lower_bound(
                   s.index().begin(),
                   s.index().end(),
                   absolutePosition,
                   [&](decltype(*s.index().begin()) const& a,
                       TypeCodeIstreamIf::StreamPos const& b){
                     return a.first < b;
                   }));
    if ((i==s.index().end())||
        ((*i).first!=s.currentPosition()-offset)){
      std::cerr << "TypeCode.hcp: no typecode " << offset << " bytes back"
                << " i.e. at position " << absolutePosition << "\n";
      throw CORBA::MARSHAL(26,CORBA::COMPLETED_NO);
    }
    std::shared_ptr<ReferenceTypeCode_> result(new ReferenceTypeCode_);
    (*i).second.second.push_back(*result);
    return TypeCode(result);
  };
  default:
    std::cerr << "TypeCode.hcp: unimplemented type kind " << (int)k << "\n";
    throw CORBA::MARSHAL(26,CORBA::COMPLETED_NO);
  }
}
TypeCode unmarshalTypeCodeFrom(TypeCodeIstreamIf& s)
//to avoid needing CORBA.h in our .hh, exception specs are commented
//throw(
//  CORBA::SystemException,
//  omni::giopStream::CommFailure
//  )
{
  auto const i(s.index().size());
  auto const p(s.currentPosition());
  s.index().push_back(
    {p,
      {(TypeCode_ const*)0,{}}});
  cxy::TypeKind k(static_cast<cxy::TypeKind>(
                    cxy::cdr<uint32_t>::unmarshalFrom(s.s())));
  TypeCode result(unmarshalTypeCodeFrom_(s,k));
  s.index()[i].second.first=&*result;
  return result;
}
}

template<>
class cdr< TypeCode >
{
public:
  static TypeCode unmarshalFrom(cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  CORBA::SystemException,
  //  omni::giopStream::CommFailure
  //  )
  {
    TypeCodeIstream s_(s);
    return unmarshalTypeCodeFrom(s_);
  }

  static void marshal(TypeCode const& x, cdrStream& s)
  //to avoid needing CORBA.h in our .hh, exception specs are commented
  //throw(
  //  omni::giopStream::CommFailure
  //)
  {
    TypeCodeOstream s_(s);
    x->marshal(s_);
  }
};
  
}
