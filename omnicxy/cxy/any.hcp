// Copyright (c) 2015 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <cxy/cdr.hh>
#include <cxy/Exception.hh>
#include <omniORB4/CORBA.h> //impl
#include <omniORB4/cdrStream.h> //impl
#include <stdint.h>
#include <sstream> //impl
#include <cxy/CDRMemOStream.hh> //impl

namespace cxy
{
cxy::Any any(int16_t x) throw()
{
  cxy::Any result(cxy::TypeKind::SHORT,"",
                  std::vector<uint8_t>(),
                  std::vector<uint8_t>()); 
  cxy::CdrMemOStream t(result.cdrEncodedTypeCode_);
  cxy::typecode<int16_t>::encode(t);
  cxy::CdrMemOStream v(result.cdrEncodedValue_);
  cxy::cdr<int16_t>::marshal(x, v);
  return result;
}

template<class T, class E>
T anyTo(cxy::Any const& x) throw(E)
{
  try {
    return anyTo_<T>(x);
  }
  catch(cxy::Exception const& e) {
    throw E(e);
  }
}

template<class T>
T anyTo<T,cxy::Exception>(cxy::Any const& x) throw(cxy::Exception)
{
  return anyTo_<T>(x);
}


template<>
int16_t anyTo_<int16_t>(cxy::Any const& x) throw(cxy::Exception)
{
  try {
    if (x.kind_ != cxy::Kind::SHORT) {
      std::ostringstream s;
      s << "Any holds a " << x.kind_ << ", not a " << cxy::Kind::SHORT;
      throw cxy::Exception(s.str(), XJU::TRACED);
    }
    cxy::CdrMemIStream v(x.cdrEncodedValue_);
    return cxy::cdr<int16_t>::unmarshalFrom(v);
  }
  catch(cxy::Exception& e) {
    std::ostringstream s;
    s << "convert specified cxy::Any to an int16_t";
    e.addContext(s.str(), XJU_TRACED);
    throw;
  }
}
