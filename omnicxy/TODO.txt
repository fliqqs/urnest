key:
  "x" means done
  "-" means to-be-done
  "~" means decided not to do

x documentation / tutorial

x once hcp-split can understand conversion operators, see //REVISIT in
  cxycref.py, adjust p15-main.cc and document in README.txt

* fix up exception handling:
  - define equivalents of all corba exception types
  - have translateCorbaException return std::exception_ptr
  - have translateException return std::exception_ptr
  - use std::rethrow_exception to throw the result

* update all tests to retry on PortInUse

x omnicxy does not work, need to pass through basename to
  hcp-split as in the generated cc it uses the .hcp basename which is
  the odin cache file name

- proto/cxy/echo-main

- how to get just direct includes (in omnipy backend)? currently picks up nested

x hand-code p1 server

    root_poa->activate_object_with_id(oid, f);

    f : PortableServer::Servant

    .. do we really need to use poa? No but seems like
    lots of work to bypass... but alas it assumes that
    the object will hang around post-deativate (deativate
    is not synchronous), based on reference counting :-(

    ... but can use a reference counted servant and wait for
    its deletion

x move m_c out of sref< ::p1::F>::f1 and into _dispatch to avoid
  malloc/free on every call

x do a cxy/p1-main.cc that uses exception class derived
  from xju::Exception as its base exception type instead of
  cxy::Exception (p1-main-e.cc) but need variants of generated files
  (subdirectory e?)

x move server_t thread into ORB (Impl)

x move generic code from cref to ORBImpl, and add translation functions
  for cxy::Exception base to other

x test port-in-use
x test port-in-use - E
x test no-such-object
x test no-such-object - E

x make sure no generated headers that would be included in
  application code include any omniORB headers (to keep
  compilation dependencies minimal)

x generate proto/cxy code from p1.idl
  x p1.hcp
  x p1.cdr.hcp
  x p1.cref.hcp
  x p1.objref.hcp
  x p1.sref.hcp

x generate proto/cxy/e code from p1.idl
  ... via eg -Wb-eE=E.hh
  x p1.hcp
  x p1.cdr.hcp
  x p1.cref.hcp
  x p1.objref.hcp
  x p1.sref.hcp

x allow "" v <> control for -e eg:
   ./x/E.hh -> "x/E.hh"
   x/E.hh -> <x/E.hh>
   ./E.hh -> "E.hh"
   E.hh -> "E.hh"

x omnicxy odin package
  idl.sm+omnicxy-be-dir=(cxy-be-dir)+hcp-split=(xxx):omnicxy
    :omnicxy is a virdir containing all generated files for the .idl
    files in idl.cxx.sm
    +hcpsplit 'hcp-split'
    +omnicxy-be-dir '' (default assumes in omniidl default search path)
    OMNICXY_PATH - enough path to run omniidl and hcpsplit if not explicit
    
x adjust sref.hcp need to derive from omniCallDescriptor to override
  unmarshalArguments

x p2.idl:
  x include p1.idl
  x basic types in params - short,long,double,string,long long,boolean
    x proto
      x .hcp
      x .cdr.hcp
      x .cref.hcp
      x .objref.hcp
      x .sref.hcp
    x gen
      x .hcp
      x .cdr.hcp
      x .cref.hcp
      x .objref.hcp
      x .sref.hcp
    x cxy/e
  x return basic types:
    x short
    x long,double,string
    proto
      x .hcp
      x .cdr.hcp
      x .cref.hcp
      x .objref.hcp
      x .sref.hcp
    gen
      x .hcp
      x .cdr.hcp
      x .cref.hcp
      x .objref.hcp
      x .sref.hcp
    x cxy/e
  
x test client wrong type exception
  x e

- p3.idl:
  x typedef basic type -> distinct
    x short
    x string
    x octet
    x float
    x double
    x long
    x long long
    x unsigned short
    x unsigned long
    x unsigned long long
    x boolean
    - wchar
    - wstring
    - long double

x p4.idl:
  x struct in param, return
  x struct declared in class (need hcp-split "friend" support)
  x translate struct XxPair { Y first; Z second; } into 
    struct XxPair : std::pair<Y,Z> XxPair { ... };
    - perhaps that should be a typedef?

x p5.idl:
  x sequence param, return, struct

x p6.idl
  x exception EEE

- p7.idl:
    - want to seamlessly handle BaseException, which
      has cause and context:
      x make use of XxPair above, specify cxy backend params
        cause=cause_,context=context_ which says to treat
        idl exception attributes cause_ and context_ as the
        BaseException cause and context attributes (so they get
        marshaled); they must have type pair<string,int> and 
        sequence<pair<string, int> >; assume they are BaseException
        members?
      x allow ExceptionCause and ExceptionContext types on omniidl
        command line
      x if EEE has those:
        x defer to the base class members
          ~ via refs where names are not cause_ and context_
        x the info will propogate back to client
      ~ if EEE does not have:
        ~ when server marshals, write them to stderr if they contain
        ~ (no: cause_ and context_ are not required in BaseException)
      x what if using own exception type? allow attr names to be
        specified on omniidl command line, as well as attr types
        specially? (e/p7-main.cc)
      - if servant throws plain BaseException allow mapping to be
        specified on command line; if no mapping abort (with stderr
        message)

- p8.idl
  - exception with cause and context mapped to BaseException and
    with extra attributes

x p9.idl:
  x oneway

x p10.idl:
  x enum

x p11.idl:
  x constant
  x enum X {A}; union(X) { A: X x_; };

x p12.idl:
  x union(X) { case A: X x_; default: Y y_; };

x p13.idl:
  x union(int) { 1: X x_; };

x p14.idl:
  x inherit interface

x p15.idl:
  x objref param/return
    cxy::IOR<X>:
    x cxy::IOR<X> cxy::sref<X>::ior() const;
      we have:
        ::PortableServer::ServantBase
        ::PortableServer::ObjectId
        omniServant
        CORBA::Object via orb.insPOA().id_to_reference(objectId)
        omniObjRef* via CORBA::Object::_PR_getobj()
        omniIOR* via omniObjRef::_getIOR()
        ... but maybe we can store a bit more info in sref_impl
        when we construct the sref_impl? Nope.
      
    x cxy::cref<X>(cxy::IOR<X> const& ior) throw();
      see see src/lib/omniORB/orbcore/omniObjRef.cc
      omniObjRef::_unMarshal
      note current uri param is only stored in cxy::objref<X> so
      ~ it can be added to exception context for a start use _toString(objRef) 
        (I don't think omniObjRef::_toString is valid on the client side)
      x use stringified IOR borrowing code from omniObjRef._toString()

x p16.idl:
  x IOR<T>::IOR(IOR<U> const& x); // only compiles if U is a T
      x implement
        x test

  x dynamic_cast
      template<class T, class U>
      cxy::cref<U> cxy::cref<T>::dynamic_cast<U>() throw(cxy::BadDynamicCast);
      x compile check U is a T
      ~ if (!obj || obj->_NP_is_nil() || obj->_NP_is_pseudo()) return _nil();
      ~ _ptr_type e = (_ptr_type) obj->_PR_getobj()->_realNarrow(_PD_repoId);
      ~ return e ? e : _nil();
      x easier to go via stringified ior to start with

x p17.idl:
  sequence<X, 1> -> optional<X>

x p18.idl:
  x untyped object ref (ie CORBA::Object) plus casting

- p19.idl:
  - sequence test cases

x memory leaks:
  x allow a repeat count, and compare eg 1 repeat v 100 with
    eg valgrind
    x p1-main (repeat the basic call)
    x p2-main (repeat "locate"+basic calls)
    x p16-main (repeat "locate"+obj ref+basic calls)

- inherit interface multi-level
- inherit multiple interfaces
- inherit interface diamond
- in-place struct union member union(short){ 1: struct X{ long a_;}; }
- recursive union
- bounded strings
    - do like bounded sequence
x p21.idl
  bounded sequences > 1
    ... nah, create own vector wrapper that does size checks
      cxy::BoundedSequence<class T, size_t MaxSize, class Allocator = std::allocator<T>,
      x like vector

- revisit BoundedSequence
      - exceptions to give them all info known eg context
      - allow construct from any such sequence same size or less
      - compile error if size greater

- arrays
    - fixed size vector? What are all non-size-changing vector methods?
    - want to be able to init from n-element "literal"
    - like BoundedSequence with only constructor from default element,
      no size-changing operations
    
- any
  * proto/cxy/p20-main-1.cc that does not actually use any and does
    not include any_.hcp nor any omniORB headers
  * proto/cxy/p20-main.cc does use Any (and does include any_.hh)
  - any is marshalled as type code then data, the data is the cdr encoding
    of the value (the length of the data is implicit in the type code)
    what is typecode? essentially parallels instance encoding
    - generate xxx.any.hcp which has specialisations of
      cxy::TypeCodeOf
    - need lots of interoperability tests
      - cxy/test-Any-interop.cc for predefined types
      - proto/cxy/test-Any-interop.cc for others

    - is there a header eg for byte order?
      - simple, no:
         - kind only: 
           tk_null, tk_void, x tk_short, tk_long, tk_ushort, tk_ulong, tk_float, tk_double, tk_boolean, tk_char, tk_octet, tk_any, tk_TypeCode, tk_Principal, tk_longlong, tk_ulonglong, tk_longdouble, tk_wchar, 
         - others have params:
           tk_string: ulong (max length or 0)
           tk_wstring: ulong(max length or zero if unbounded)
	   tk_fixed: ushort(digits), short(scale)

      x "complex" typecodes are encapsulated ie they are
        encoded as sequence<octet> where the sequence<octet> has
        a byte order byte followed by cdr encodings. Use 
        cdrEncapsulationStream? How to marshal it?
           ~/omniORB-4.2.0/src/lib/omniORB/dynamic/typecode.cc:5049 / 5233

      x value of any is not encapsulated, therefore need to decode the
        typecode to be able to figure out how big the value is
        tk_objref: string (repository ID), string(name)
        tk_struct: string (repository ID),
                    string (name),
                   ulong (count)
                  {string (member name),
                 TypeCode (member type)}
        tk_union: string (repository ID), string(name),
                   TypeCode (discriminant type),
                  long (default used),
                 ulong (count)
                {discriminant typea (label value),
               string (member name),
              TypeCode (member type)}
        tk_enum: string (repository ID),
                  string (name),
                 ulong (count)
                {string (member name)}
        tk_sequence: TypeCode (element type),
                      ulong (max lengthc)
        tk_array: TypeCode (element type),
                   ulong (length)
        tk_alias: string (repository ID),
                   string (name),
                  TypeCode
        tk_except: string (repository ID),
                    string (name),
                   ulong (count)
                  {string (member name),
                 TypeCode (member type)}
        - step through omni orb encoding of a struct to see how it
          does the encapsulation
         ~/omniORB-4.2.0/src/lib/omniORB/dynamic/typecode.cc:5049
         ... is the interesting bit

    - recursion/indirection in typecodes:
      - want to store as just TypeCode const*, but when we get to the
        referer we have not necessarily created the referee, so perhaps
        use 2x maps: map<offset,TypeCode const*> for those we know,
        multimap<offset, std::reference<TypeCode const*> > for those we 
        don't know (and fill them as we create the referee)
      - encoding needs the corrolery map<fqn,offset> ... might need
        more if idl allows cross-linked structures (C++ appears to)
        No: 9.3.4.3 Scope of the Indirections states "Non-negative offsets are
        reserved for future use."
      - use struct N from test-nested as a test case
        - typecode for sequence
        - typecode for struct
      - need to undestand typecode offset v encapsulation... corba.pdf states
        encapsulation allows pre-marshalling, therefore inside encapsulation,
        offset must stay within encapsulation? Yes - 9.3.4.3 Scope of the 
        Indirections explicitly states this as 
        "Indirections may not cross encapsulation boundaries."

    - interop/test-Any.cc :
      x encode cxy, decode cxx and vice-versa, use cdrMemoryStream
      x can't do cxx and cxy in same process for same interface
        because they generate the same namespaces, so:
        x main process does cxy, sub process does cxx (because cxy
          cleans up reliably and can simply kill subprocess)
        x main process needs to create a server before starting subprocess
          x main creates a::server
          x main starts sub
          x sub gets corbaloc of a::server
          x sub creates reflect implementation
          x sub calls main a::server::run passing reflect implementation
          x main a::server::run does the test cases then returns
          x sub exits
          x main collects exit status and exits
      x CORBA::Short
      - other types

    - optimisation:
      add TypeCode::minEncodedValueSize() and use as initial value buffer size

    x rename Any to AnyImpl and do a Any template to translate exceptions
    * can share AnyImpl (make it const)

- cxy/Time.idl and hand-code cxy/Time.hcp to inherit from std::time_point
- cxy/Duration.idl and hand-code cxy/Duration.hcp to inherit also

- other stuff (see omniidl idltypes.py)

- cxysref.py generates dispatch code for all inherited operations, which
  will result in lots of duplicate code, instead call the dispatch code
  for the inherited interface
    - how to tell in omniidl backend which is inherited operation?

- try to remove all omniORB headers from all other generated:
  - .cc
  - objref.hcp

- try to remove all omniORB headers from cxy/*.hh too

- should not need cref at all, should be able to use standard pointer eg
  std::unique_ptr<T> cxy::cref<T>::locate(...)
  ... but downside is not then able to narrow? Actually might be
  able to narrow via a cxy::cref<T>::narrow(U), it can first narrow
  to a objref<U> then do the usual stuff

- compile errors (make sure they're meaningful):
  IOR conversion to unrelated type
  narrow to unrelated type
  use of cref<T> without including appropriate header
  use of sref<T> without including appropriate header

- operator<<(std::ostream&,IORImpl) better to describe the IOR type and
  tagged profile list (could use catior?) see REVISIT in cxy::IORImpl

x test duplicate object name exception

- add a two-process client server test
  - cxx->cxy, for each single-process test
  - cxy->cxx, for each single-process test
  - p9 test should verify oneway is asynchronous

- allow cref cons/assign from super-class-cref

x client side:

x can get (CORBA_Object.h class Object) CORBA::Object* from 
  ORB::string_to_object
x then generated code calls CORBA::Object::_PR_getobj()->_realNarrow(
   _PD_repoId), _PR_getobj() is just 
    (omniObjRef.h) omniObjRef* CORBA::Object::pd_obj
x ... generated code has a static _pof_F which is a
  proxyObjectFactory and it has a omniObjRef* newObjRef that
  returns a generated class p1::_objref_F : omniObjRef
x   which has an implementation of each method


x allow "unchecked narrow"? Na

x clean up xju::Exceptions, get it back to a minimum of function
  variants:
    x add cxy::Exception which uses xju::Exception as its implementation
    x change xju::Exception back
    x have cxy/* throw cxy::Exceptions<cxy::Exception>::X and
      provide translate of all those to cxy::Exceptions<Y>::X with
      null-translation overrides

- translate the various system exceptions eg Transient
  separately in translateException.hcp

x make p1.hh // impl in p1.sref.hcp

- allow servant to throw base exception

- make uri cxy::objref<X> cons param

- have seen cxx p2-main crash at end (after calling orb->destroy()), why?:

#5  0x00007f6924661ab8 in __cxxabiv1::__cxa_throw (obj=0x7f6914000970, 
    tinfo=0x7f6924f036b0 <typeinfo for CORBA::OBJECT_NOT_EXIST>, 
    dest=0x7f6924c11e80 <CORBA::OBJECT_NOT_EXIST::~OBJECT_NOT_EXIST()>)
    at ../../.././libstdc++-v3/libsupc++/eh_throw.cc:87
#6  0x00007f6924c07efd in omniOrbORB::run() ()
   from /home/xju/omniORB-4.2.0/lib/libomniORB4.so.2
#7  0x0000000000407522 in xju::mt::Thread<CORBA::ORB>::main (x=0x7ffde4b5f350)
    at /home/xju/urnest/xju/mt.hh:350

#5  0x00007f6924661ab8 in __cxxabiv1::__cxa_throw (obj=0x7f6914000970, 
    tinfo=0x7f6924f036b0 <typeinfo for CORBA::OBJECT_NOT_EXIST>, 
    dest=0x7f6924c11e80 <CORBA::OBJECT_NOT_EXIST::~OBJECT_NOT_EXIST()>)
    at ../../.././libstdc++-v3/libsupc++/eh_throw.cc:87
#6  0x00007f6924c07efd in omniOrbORB::run() ()
   from /home/xju/omniORB-4.2.0/lib/libomniORB4.so.2
#7  0x0000000000407522 in xju::mt::Thread<CORBA::ORB>::main (x=0x7ffde4b5f350)
    at /home/xju/urnest/xju/mt.hh:350

---------------------------------------------

xju@xjutv:~/urnest$ ODIN_LIB_SP="/usr/local/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be  ODIN_CXX_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib ODIN_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib ODIN_CXX_I=/usr/local/omniORB-4.2.0/include odin/create-linux-cache.sh $ODIN

 ODIN_LIB_SP="/home/xju/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/home/xju/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_PATH=/home/xju/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be  ODIN_CXX_LD_LIBRARY_PATH=/home/xju/omniORB-4.2.0/lib ODIN_LD_LIBRARY_PATH=/home/xju/omniORB-4.2.0/lib ODIN_CXX_I=/home/xju/omniORB-4.2.0/include odin/create-linux-cache.sh $ODIN

#gcc 5.2.0:
ODIN_CXX_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib  ODIN_CXX_PATH=/home/xju/gcc-5.2.0-run/bin:/usr/bin:/bin ODIN_CXX_FLAGS=-std=c++11 ODIN_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib ODIN_CXX_I=/usr/local/omniORB-4.2.0/include ODIN_LIB_SP="/usr/local/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/usr/local/omniORB-4.2.0/bin:/bin:/usr/bin ODIN_OMNICXY_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be ./odin/create-linux-cache.sh $ODIN
