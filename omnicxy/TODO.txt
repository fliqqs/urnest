key:
  "x" means done
  "-" means to-be-done
  "~" means decided not to do

* p16-main core dump
  omniObjRef::_getIOR return value ownership?
  x- step through using omniORB debug build
  x a's obj_ seems broken when we come to use it at line 207
  x was it always broken? Yes
  - why is it broken? Need to look at equivalent cxx code?
  - see how it was constructed

x cxy::any operator< etc

- union: promote variant structure members to get more natural
  C++ code, if can only have one data type per variant type
  - consider using latest C++ standard technique, it looks like a close match?
  
~ union return as std::unique_ptr, in as T const&
  no that makes embedding union types in structures harder, just
  stick with shared_ptr<T const>

* fix up exception handling:
  - define equivalents of all corba exception types
  - have translateCorbaException return std::exception_ptr
  - have translateException return std::exception_ptr
  - use std::rethrow_exception to throw the result

* allow retry after PortInUse (with different port; currently retries same
  port always ... omniORB needs mod?)
  
* update all tests to retry on PortInUse

- proto/cxy/echo-main

- how to get just direct includes (in omnipy backend)? currently picks up nested

- use xju::Thread instead of xju::mt::Thread

- p3.idl:
  x typedef basic type -> distinct
    x short
    x string
    x octet
    x float
    x double
    x long
    x long long
    x unsigned short
    x unsigned long
    x unsigned long long
    x boolean
    - wchar ... code incorrect, much more complex
    - wstring
    - long double

    struct XxPair : std::pair<Y,Z> XxPair { ... };
    - perhaps that should be a typedef?

- p7.idl:
    - want to seamlessly handle BaseException, which
      has cause and context:
      x make use of XxPair above, specify cxy backend params
        cause=cause_,context=context_ which says to treat
        idl exception attributes cause_ and context_ as the
        BaseException cause and context attributes (so they get
        marshaled); they must have type pair<string,int> and 
        sequence<pair<string, int> >; assume they are BaseException
        members?
      x allow ExceptionCause and ExceptionContext types on omniidl
        command line
      x if EEE has those:
        x defer to the base class members
          ~ via refs where names are not cause_ and context_
        x the info will propogate back to client
      ~ if EEE does not have:
        ~ when server marshals, write them to stderr if they contain
        ~ (no: cause_ and context_ are not required in BaseException)
      x what if using own exception type? allow attr names to be
        specified on omniidl command line, as well as attr types
        specially? (e/p7-main.cc)
      - if servant throws plain BaseException allow mapping to be
        specified on command line; if no mapping abort (with stderr
        message)

- p8.idl
  - exception with cause and context mapped to BaseException and
    with extra attributes

- p19.idl:
  - sequence test cases

- inherit interface multi-level
- inherit multiple interfaces
- p23.idl:
  - inherit interface diamond

x p16a-main:
    x inherit base implementation:
      interface IfA { void f(); }
      interface IfB : IfA { void g(); }
      class A : public virtual IfA { void f() { ...; } };
      class B : public virtual A, public virtual IfB {
        void g() { ...; }
      };
      x remote access a B as an A
      x narrow to a B
      ... just like p16
    
- in-place struct union member union(short){ 1: struct X{ long a_;}; }
- recursive union
- bounded strings
    - do like bounded sequence

- revisit BoundedSequence
      - exceptions to give them all info known eg context
      - allow construct from any such sequence same size or less
      - compile error if size greater

- arrays
    - fixed size vector? What are all non-size-changing vector methods?
    - want to be able to init from n-element "literal"
    - like BoundedSequence with only constructor from default element,
      no size-changing operations
    
- any
  x string
  - array
  - union
  
  * proto/cxy/p20-main-1.cc that does not actually use any and does
    not include any_.hcp nor any omniORB headers
  x proto/cxy/p20-main.cc does use Any (and does include any_.hh)
  - any is marshalled as type code then data, the data is the cdr encoding
    of the value (the length of the data is implicit in the type code)
    what is typecode? essentially parallels instance encoding
    - generate xxx.any.hcp which has specialisations of
      cxy::TypeCodeOf
    - need lots of interoperability tests
      - cxy/test-Any-interop.cc for predefined types
      - proto/cxy/test-Any-interop.cc for others

    - is there a header eg for byte order?
      - simple, no:
         - kind only: 
           tk_null, tk_void, x tk_short, tk_long, tk_ushort, tk_ulong, tk_float, tk_double, tk_boolean, tk_char, tk_octet, tk_any, tk_TypeCode, tk_Principal, tk_longlong, tk_ulonglong, tk_longdouble, tk_wchar, 
         - others have params:
           tk_string: ulong (max length or 0)
           tk_wstring: ulong(max length or zero if unbounded)
	   tk_fixed: ushort(digits), short(scale)

      x "complex" typecodes are encapsulated ie they are
        encoded as sequence<octet> where the sequence<octet> has
        a byte order byte followed by cdr encodings. Use 
        cdrEncapsulationStream? How to marshal it?
           ~/omniORB-4.2.0/src/lib/omniORB/dynamic/typecode.cc:5049 / 5233

      x value of any is not encapsulated, therefore need to decode the
        typecode to be able to figure out how big the value is
        tk_objref: string (repository ID), string(name)
        tk_struct: string (repository ID),
                    string (name),
                   ulong (count)
                  {string (member name),
                 TypeCode (member type)}
        tk_union: string (repository ID), string(name),
                   TypeCode (discriminant type),
                  long (default used),
                 ulong (count)
                {discriminant typea (label value),
               string (member name),
              TypeCode (member type)}
        tk_enum: string (repository ID),
                  string (name),
                 ulong (count)
                {string (member name)}
        tk_sequence: TypeCode (element type),
                      ulong (max lengthc)
        tk_array: TypeCode (element type),
                   ulong (length)
        tk_alias: string (repository ID),
                   string (name),
                  TypeCode
        tk_except: string (repository ID),
                    string (name),
                   ulong (count)
                  {string (member name),
                 TypeCode (member type)}
        - step through omni orb encoding of a struct to see how it
          does the encapsulation
         ~/omniORB-4.2.0/src/lib/omniORB/dynamic/typecode.cc:5049
         ... is the interesting bit

    - recursion/indirection in typecodes:
      - want to store as just TypeCode const*, but when we get to the
        referer we have not necessarily created the referee, so perhaps
        use 2x maps: map<offset,TypeCode const*> for those we know,
        multimap<offset, std::reference<TypeCode const*> > for those we 
        don't know (and fill them as we create the referee)
      - encoding needs the corrolery map<fqn,offset> ... might need
        more if idl allows cross-linked structures (C++ appears to)
        No: 9.3.4.3 Scope of the Indirections states "Non-negative offsets are
        reserved for future use."
      - use struct N from test-nested as a test case
        - typecode for sequence
        - typecode for struct
      - need to undestand typecode offset v encapsulation... corba.pdf states
        encapsulation allows pre-marshalling, therefore inside encapsulation,
        offset must stay within encapsulation? Yes - 9.3.4.3 Scope of the 
        Indirections explicitly states this as 
        "Indirections may not cross encapsulation boundaries."

    - interop/test-Any.cc :
      x encode cxy, decode cxx and vice-versa, use cdrMemoryStream
      x can't do cxx and cxy in same process for same interface
        because they generate the same namespaces, so:
        x main process does cxy, sub process does cxx (because cxy
          cleans up reliably and can simply kill subprocess)
        x main process needs to create a server before starting subprocess
          x main creates a::server
          x main starts sub
          x sub gets corbaloc of a::server
          x sub creates reflect implementation
          x sub calls main a::server::run passing reflect implementation
          x main a::server::run does the test cases then returns
          x sub exits
          x main collects exit status and exits
      x CORBA::Short
      - other types

    - optimisation:
      add TypeCode::minEncodedValueSize() and use as initial value buffer size

    - adjust so Any.hh does not include TypeCode.hh (which means
      can use interfaces that contain anys without it?
    
    x rename Any to AnyImpl and do a Any template to translate exceptions
    * can share AnyImpl (make it const)

    - test interop with complex any param
    
- cxy/Milliseconds.idl and hand-code map to std::chrono::milliseconds

- other stuff (see omniidl idltypes.py)

- cxysref.py generates dispatch code for all inherited operations, which
  will result in lots of duplicate code, instead call the dispatch code
  for the inherited interface
    - how to tell in omniidl backend which is inherited operation?

- try to remove all omniORB headers from all other generated:
  - .cc
  - objref.hcp

- try to remove all omniORB headers from cxy/*.hh too

- should not need cref at all, should be able to use standard pointer eg
  std::unique_ptr<T> cxy::cref<T>::locate(...)
  ... but downside is not then able to narrow? Actually might be
  able to narrow via a cxy::cref<T>::narrow(U), it can first narrow
  to a objref<U> then do the usual stuff

- compile errors (make sure they're meaningful):
  IOR conversion to unrelated type
  narrow to unrelated type
  use of cref<T> without including appropriate header
  use of sref<T> without including appropriate header

- operator<<(std::ostream&,IORImpl) better to describe the IOR type and
  tagged profile list (could use catior?) see REVISIT in cxy::IORImpl

- add a two-process client server test
  - cxx->cxy, for each single-process test
  - cxy->cxx, for each single-process test
  - p9 test should verify oneway is asynchronous

- allow cref cons/assign from super-class-cref

- translate the various system exceptions eg Transient
  separately in translateException.hcp

- allow servant to throw base exception

- make uri cxy::objref<X> cons param

- have seen cxx p2-main crash at end (after calling orb->destroy()), why?:

#5  0x00007f6924661ab8 in __cxxabiv1::__cxa_throw (obj=0x7f6914000970, 
    tinfo=0x7f6924f036b0 <typeinfo for CORBA::OBJECT_NOT_EXIST>, 
    dest=0x7f6924c11e80 <CORBA::OBJECT_NOT_EXIST::~OBJECT_NOT_EXIST()>)
    at ../../.././libstdc++-v3/libsupc++/eh_throw.cc:87
#6  0x00007f6924c07efd in omniOrbORB::run() ()
   from /home/xju/omniORB-4.2.0/lib/libomniORB4.so.2
#7  0x0000000000407522 in xju::mt::Thread<CORBA::ORB>::main (x=0x7ffde4b5f350)
    at /home/xju/urnest/xju/mt.hh:350

#5  0x00007f6924661ab8 in __cxxabiv1::__cxa_throw (obj=0x7f6914000970, 
    tinfo=0x7f6924f036b0 <typeinfo for CORBA::OBJECT_NOT_EXIST>, 
    dest=0x7f6924c11e80 <CORBA::OBJECT_NOT_EXIST::~OBJECT_NOT_EXIST()>)
    at ../../.././libstdc++-v3/libsupc++/eh_throw.cc:87
#6  0x00007f6924c07efd in omniOrbORB::run() ()
   from /home/xju/omniORB-4.2.0/lib/libomniORB4.so.2
#7  0x0000000000407522 in xju::mt::Thread<CORBA::ORB>::main (x=0x7ffde4b5f350)
    at /home/xju/urnest/xju/mt.hh:350

---------------------------------------------

xju@xjutv:~/urnest$ ODIN_LIB_SP="/usr/local/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be  ODIN_CXX_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib ODIN_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib ODIN_CXX_I=/usr/local/omniORB-4.2.0/include odin/create-linux-cache.sh $ODIN

 ODIN_LIB_SP="/home/xju/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/home/xju/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_PATH=/home/xju/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be  ODIN_CXX_LD_LIBRARY_PATH=/home/xju/omniORB-4.2.0/lib ODIN_LD_LIBRARY_PATH=/home/xju/omniORB-4.2.0/lib ODIN_CXX_I=/home/xju/omniORB-4.2.0/include odin/create-linux-cache.sh $ODIN

#gcc 5.2.0:
ODIN_CXX_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib  ODIN_CXX_PATH=/home/xju/gcc-5.2.0-run/bin:/usr/bin:/bin ODIN_CXX_FLAGS=-std=c++11 ODIN_LD_LIBRARY_PATH=/usr/local/omniORB-4.2.0/lib:/home/xju/gcc-5.2.0-run/lib ODIN_CXX_I=/usr/local/omniORB-4.2.0/include ODIN_LIB_SP="/usr/local/omniORB-4.2.0/lib /lib /usr/lib" ODIN_EXEC_PATH=/usr/local/omniORB-4.2.0/bin:/bin:/usr/bin ODIN_OMNICXY_PATH=/usr/local/omniORB-4.2.0/bin:/usr/bin:/bin ODIN_OMNICXY_BE_DIR=~/urnest/omnicxy/omniidl_be ./odin/create-linux-cache.sh $ODIN
