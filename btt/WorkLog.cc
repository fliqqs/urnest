//     -*- mode: c++ ; c-file-style: "osse" ; -*-
//
// Copyright (c) 2003
// Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//
//    REVISIT: try implementing with boost::filesystem
//
#include <btt/WorkLog.hh>


#include <sstream>
#include <xju/format.hh>
#include <algorithm>
#include <xju/stringToInt.hh>
#include <xju/assert.hh>
#include <ctype.h>
#include <xju/syscall.hh>
#include <xju/unistd.hh>
#include <xju/fcntl.hh>
#include <sys/types.h>
#include <unistd.h>
#include <xju/formatTime.hh>

#ifdef __MINGW32__
#include <windows.h>
#endif

namespace
{
    //
    // pre:  entry.second.str() contains no new lines
    // post: result contains no newlines
    //       parseEntry(result) = entry
    //
    std::string formatEntry(const btt::WorkLog::Entry& entry) throw()
    {
	std::ostringstream s;
	s << xju::format::int_(entry.first.getSecs())
	  << "."
	  << xju::format::int_(entry.first.getUsecs(), 6, '0')
	  << " "
	  << entry.second;
	return s.str();
    }

    //
    // pre:  x was generated by formatEntry()
    // post: for x generated by formatEntry(y), result = y
    //
    btt::WorkLog::Entry parseEntry(const std::string& x) throw()
    {
	std::string::const_iterator i(std::find(x.begin(), x.end(), '.'));
	xju::assert_not_equal(i, x.end());
	const unsigned int secs(
	    xju::stringToInt(std::string(x.begin(), i)));
	
	++i;
	xju::assert_not_equal(i, x.end());
	std::string::const_iterator j(find_if(i, x.end(), ::isspace));
	xju::assert_not_equal(j, x.end());
	xju::assert_equal(j - i, 6);
	
	const unsigned int usecs(
	    xju::stringToInt(std::string(i, j)));
	i=j;
	++i;
	const btt::TaskId task(std::string(i, x.end()));
	
	return btt::WorkLog::Entry(
	    xju::Time(secs, usecs),
	    task);
    }

    //
    // Returns file descriptor open for reading.
    //
    int openWorkLogFileReadOnly(const std::string& fileName) throw(
	//
	// pre: open failed
	//
	xju::Exception)
    {
	try
	{
	    try
	    {
#ifdef _WIN32
		return xju::syscall(xju::open, XJU_TRACED)(
		    fileName.c_str(), O_RDONLY | O_CREAT | O_BINARY, 0777);
#else
		return xju::syscall(xju::open, XJU_TRACED)(
		    fileName.c_str(), O_RDONLY | O_CREAT, 0777);
#endif
	    }
	    catch(xju::Exception& e)
	    {
		std::ostringstream s;
		s << "open work log file " << fileName
		  << " read-only";
		e.addContext(s, XJU_TRACED);
		throw;
	    }
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "wrap work log file " << fileName;
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }

    //
    // Return file descriptor open for writing on the
    // specified work log file.
    //
    int openWorkLogFileWritable(const std::string& fileName) throw(
	xju::Exception)
    {
	try
	{
#ifdef _WIN32
	    return xju::syscall(xju::open, XJU_TRACED)(
		fileName.c_str(),
		O_WRONLY | O_CREAT | O_APPEND | O_BINARY,
		0777);
#else
	    return xju::syscall(xju::open, XJU_TRACED)(
		fileName.c_str(),
		O_WRONLY | O_CREAT | O_APPEND,
		0777);
#endif
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "open work log file " << fileName
	      << " for writing";
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }

    //
    // Get the character at the specified offset from the
    // start of the file readable via the specified file
    // descriptor.
    //
    char charAtOffset(const int fd, const off_t offset) throw(
	xju::Exception)
    {
	try
	{
	    xju::syscall(xju::lseek, XJU_TRACED)(
		fd,
		offset,
		SEEK_SET);
	    char c(0);
	    xju::assert_equal(
		xju::syscall(xju::read, XJU_TRACED)(fd, &c, 1),
		1);
	    return c;
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "get the character " << offset
	      << " bytes from the start of the specified file";
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }
    
}

namespace btt
{
    WorkLog::WorkLog(const std::string& fileName) throw(xju::Exception) :
	fileName_(fileName),
	fd_(openWorkLogFileReadOnly(fileName))
    {
    }

    void WorkLog::logWorkingOnTaskSince(
	const TaskId& task,
	const xju::Time& since) throw(
	    xju::Exception)
    {
	try
	{
	    if (!wfd_.get())
	    {
		wfd_ = std::unique_ptr<xju::AutoFd>(
		    new xju::AutoFd(openWorkLogFileWritable(fileName_)));
	    }
	    if (rbegin() != rend() &&
		since < (*rbegin()).first)
	    {
		std::ostringstream r;
		r << "the last entry in log file " << fileName_ 
		  << " indicates that you started working on task with id "
		  << (*rbegin()).second
		  << " at "
		  << xju::formatTime((*rbegin()).first)
		  << ", which is after "
		  << xju::formatTime(since)
		  << ". Functionality to record this fact is not "
		  << "implemented";
		throw xju::Exception(r, XJU_TRACED);
	    }

	    const std::string es(formatEntry(Entry(since, task))+"\n");
	    xju::syscall(xju::lseek, XJU_TRACED)(
		wfd_->value_,
		0,
		SEEK_END);
	    xju::syscall(xju::write, XJU_TRACED)(
		wfd_->value_,
		es.c_str(),
		es.size());
	    entryAdded_();
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "record that you have been working on task with id "
	      << task
	      << " since "
	      << xju::formatTime(since);
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }
    const xju::Event& WorkLog::entryAdded() const throw()
    {
	return entryAdded_;
    }

#ifdef __MINGW32__
    namespace
    {
	void ftruncate(const std::string& fileName, const off_t offset) throw(
	    xju::Exception)
	{
	    try
	    {
		HANDLE f = CreateFile(
		    fileName.c_str(),
		    GENERIC_WRITE,        // access mode
		    FILE_SHARE_WRITE,     // share mode
		    0, // SD
		    OPEN_EXISTING,        // how to create
		    FILE_ATTRIBUTE_NORMAL, // file attributes
		    0                        // handle to template file
		    );
		if (f == INVALID_HANDLE_VALUE)
		{
		    std::ostringstream s;
		    s << "open failed with error "
		      << GetLastError();
		    throw xju::Exception(s, XJU_TRACED);
		}
		DWORD p = SetFilePointer(
		    f,                // handle to file
		    offset,        // bytes to move pointer
		    0,  // bytes to move pointer
		    FILE_BEGIN           // starting point
		    );
		if (p == INVALID_SET_FILE_POINTER)
		{
		    throw xju::Exception("set truncation offset", XJU_TRACED);
		}
		
		if (!SetEndOfFile(f))
		{
		    throw xju::Exception("truncate file", XJU_TRACED);
		}
		CloseHandle(f);
	    }
	    catch(xju::Exception& e)
	    {
		std::ostringstream s;
		s << "truncate file " << fileName << " at offset " << offset;
		e.addContext(s, XJU_TRACED);
		throw;
	    }
	}
    }
#endif
    
    void WorkLog::pop_back() throw(
	xju::Exception)
    {
	xju::assert_not_equal(rbegin(), rend());

	try
	{
	    if (!wfd_.get())
	    {
		wfd_ = std::unique_ptr<xju::AutoFd>(
		    new xju::AutoFd(openWorkLogFileWritable(fileName_)));
	    }
	    const_reverse_iterator i(rbegin());
	    ++i;
	    
	    const off_t offset(i.offset_);
	    try
	    {
#ifndef __MINGW32__
		xju::syscall(xju::ftruncate, XJU_TRACED)(
		    wfd_->value_,
		    offset);
#else
		wfd_ = std::unique_ptr<xju::AutoFd>();
		::close(fd_.value_);
		ftruncate(fileName_, offset);
		fd_.value_ = openWorkLogFileReadOnly(fileName_);
#endif
		lastEntryRemoved_();
	    }
	    catch(xju::Exception& e)
	    {
		std::ostringstream s;
		s << "truncate file " << fileName_
		  << " at offset " << offset;
		e.addContext(s, XJU_TRACED);
		throw;
	    }
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "remove (i.e. delete) the last entry in work log file "
	      << fileName_;
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }
    const xju::Event& WorkLog::lastEntryRemoved() const throw()
    {
	return lastEntryRemoved_;
    }

    WorkLog::const_reverse_iterator::const_reverse_iterator(
	const std::string& fileName,
	const int& fd,
	const off_t offset) throw():
	fileName_(fileName),
	fd_(fd),
	offset_(offset)
    {
    }

    bool WorkLog::const_reverse_iterator::operator==(
	const WorkLog::const_reverse_iterator i) const throw()
    {
	xju::assert_equal(i.fd_, fd_);
	return i.offset_ == offset_;
    }

    WorkLog::Entry WorkLog::const_reverse_iterator::operator*() const throw(
	xju::Exception)
    {
	try
	{
	    xju::assert_not_equal(offset_, 0);
	    off_t start(offset_-1);
	    char c[2];
	    c[1] = 0;
	    std::string es;

	    while(start && (c[0]=charAtOffset(fd_, start-1)) != '\n')
	    {
		es = std::string(c) + es;
		--start;
	    }
	    
	    return parseEntry(es);
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "read entry (ending) at offset "
	      << offset_
	      << " in work log file " << fileName_;
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }

    WorkLog::const_reverse_iterator&
    WorkLog::const_reverse_iterator::operator++() throw(
	xju::Exception)
    {
	xju::assert_not_equal(offset_, 0);
	
	try
	{
	    off_t start(offset_-1);
	    while(start && charAtOffset(fd_, start-1) != '\n')
	    {
		--start;
	    }
	    offset_ = start;
	    return *this;
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "locate entry in log file " << fileName_
	      << " before the entry (ending) at " << offset_;
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }

    WorkLog::const_reverse_iterator
    WorkLog::rbegin() const throw(xju::Exception)
    {
	try
	{
	    const off_t e(xju::syscall(xju::lseek, XJU_TRACED)(
		fd_.value_,
		0,
		SEEK_END));
	    return const_reverse_iterator(fileName_, fd_.value_, e);
	}
	catch(xju::Exception& e)
	{
	    std::ostringstream s;
	    s << "seek to end of work log file " << fileName_;
	    e.addContext(s, XJU_TRACED);
	    throw;
	}
    }

    WorkLog::const_reverse_iterator 
    WorkLog::rend() const throw()
    {
	return const_reverse_iterator(fileName_, fd_.value_, 0);
    }
}
