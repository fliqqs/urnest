// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <dion/JobIds.hh>
#include <dion/Date.hh>
#include <xju/Optional.hh>
#include <dion/Executor.hh>
#include <xju/assert.hh> //impl

namespace dion
{
class Node
{
private:
  // we (directly or due to an input) are awaiting one or more
  // in-progress jobs in order to bring our state up to date.
  JobIds awaiting_;
  Date verifiedAt_;

  // job in progress that will bring us up to date calculatingAt_.value()
  xju::Optional<Date> calculatingAt_;
  
public:
  Node(JobIds awaiting,
       Date verifiedAt):
      awaiting_(std::move(awaiting)),
      verifiedAt_(std::move(verifiedAt)),
      callMeWhenExecutorNotBusy_(false)
  {
  }

  virtual ~Node() noexcept {}

  // Node wants update() called as soon as executor is not busy
  bool callMeWhenExecutorNotBusy_;
  
  // Bring all inputs and own state up to date now.
  // - to update an input, call input->update(now, executor)
  // - do not start job (throw JobSpec to start job)
  virtual void updateInputsAndState(Date now, Executor& executor)
    // throws JobIds if inputs are awaiting jobs
    // throws JobSpec if needs external command job run
    // throws Executor::FlatOut passed through from input update()
    = 0;

  // Tell any relevant inputs that js is done by calling
  // each's jobsDone(js).
  virtual void tellInputsThatJobsAreDone(JobIds const& js) noexcept = 0;

  // Collect result of job j completing state update.
  virtual void collectResultOfJob(Executor& e,
                                  JobId const& j) noexcept = 0;
  
  // Bring this node up to date now.
  // - makes use of type-specific updateInputsAndState above as appropriate
  void update(Date now, Executor& executor)
  // throws JobIds if update awaits jobs
  {
    while(verifiedAt_ < now){
      xju::assert_equal(calculatingAt_.valid(), false);
      try{
        // anything we were waiting for no longer in progress?
        auto const noLongerInPrgoress(awaiting_ - executor.jobsInProgress());
        if ((noLongerInPrgoress != JobIds()) || callMeWhenExecutorNotBusy_)
        {
          callMeWhenExecutorNotBusy_ = false;
          updateInputsAndState(now, executor);
          awaiting_ = JobIds();
          verifiedAt_ = now;
          return;
        }
        xju::assert_not_equal(awaiting_, JobIds());
        throw awaiting_;
      }
      catch(JobIds awaiting){
        awaiting_ = awaiting;
        throw;
      }
      catch(Executor::JobSpec const& s){
        try{
          awaiting_ = executor.startJob(now, s);
          throw awaiting_;
        }
        catch(Executor::FlatOut const&){
          callMeWhenExecutorNotBusy_ = true;
          throw;
        }
      }
    }
  }
  void jobsDone(JobIds const& j, Executor& e) noexcept
  {
    auto relevant = awaiting_ & j;
    if (relevant != JobIds()){
      if (calculatingAt_.valid()){
        // since we were calculating, the only thing we
        // can be awaiting is our own job
        xju::assert_equal(relevant, awaiting_);
        collectResultOfJob(e,relevant.onlyJob());
        verifiedAt_ = calculatingAt_.value();
        calculatingAt_.clear();
      }
      else{
        tellInputsThatJobsAreDone(relevant);
        callMeWhenExecutorNotBusy_ = true;
      }
      awaiting_.remove(j);
    }
  }
};

}
