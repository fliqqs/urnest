// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//

#include <dion/JobIds.hh>
#include <dion/Date.hh>
#include <xju/Optional.hh>
#include <dion/Executor.hh>
#include <xju/assert.hh> //impl

namespace dion
{
class Node
{
private:
  // we (directly or due to an input) are awaiting one or more
  // in-progress jobs in order to bring our state up to date.
  JobIds awaiting_;
  Date verifiedAt_;

  // job in progress that will bring us up to date calculatingAt_.value()
  xju::Optional<Date> calculatingAt_;
  
public:
  Node(JobIds awaiting,
       Date verifiedAt):
      awaiting_(std::move(awaiting)),
      verifiedAt_(std::move(verifiedAt))
  {
  }

  virtual ~Node() noexcept {}

  JobIds awaiting() const noexcept
  {
    return awaiting_;
  }
  Date verifiedAt() const noexcept
  {
    return verifiedAt_;
  }
  
  // Bring all inputs and own state up to date now.
  // - to update an input, call input->update(now, executor)
  // - do not start job, instead throw JobSpec to start job
  virtual void updateInputsAndState(Date now, Executor& executor)
    // throws JobIds if inputs are awaiting jobs
    // throws JobSpec if needs external command job run
    = 0;

  // Tell any relevant inputs that js is done by calling
  // each's jobsDone(js).
  virtual void tellInputsThatJobsAreDone(JobIds const& js) noexcept = 0;

  // Collect result of job j completing state update.
  virtual void collectResultOfJob(Executor& e,
                                  JobId const& j) noexcept = 0;
  
  // Bring this node up to date now.
  // - makes use of type-specific updateInputsAndState above as appropriate
  // post: awaiting() == JobIds() && verifiedAt() >= now
  void update(Date now, Executor& executor)
  // throws awaiting() if update awaits jobs
  {
    try{
      if(verifiedAt_ < now){
        // result of our job is always delivered via jobsDone before
        // our calculate is called again
        
        xju::assert_equal(calculatingAt_.valid(), false);
        // anything we were waiting for no longer in progress?
        auto const noLongerInProgress(awaiting_ - executor.jobsInProgress());
        if (noLongerInProgress != JobIds())
        {
          try{
            updateInputsAndState(now, executor);
            awaiting_ = JobIds();
            verifiedAt_ = now;
          }
          catch(Executor::JobSpec const& s){
            JobIds j(executor.startJob(now, s));
            calculatingAt_=now;
            throw j;
          }
        }
        else{
          xju::assert_not_equal(awaiting_, JobIds());
          throw awaiting_;
        }
      }
    }
    catch(JobIds const& awaiting){
      awaiting_ = awaiting;
      throw;
    }
  }

  // note to avoid unecessary tree traversal, exclude
  // e.executorNotBusyJob() from j before calling
  void jobsDone(JobIds const& j, Executor& e) noexcept
  {
    auto relevant = awaiting_ & j;
    if (relevant != JobIds()){
      awaiting_.remove(relevant);
      if (calculatingAt_.valid()){
        // since we were calculating, the only thing we
        // can be awaiting is our own job
        xju::assert_equal(awaiting_, JobIds());
        collectResultOfJob(e,relevant.onlyJob());
        verifiedAt_ = calculatingAt_.value();
        calculatingAt_.clear();
      }
      else{
        tellInputsThatJobsAreDone(relevant);
        // some node in our subtree has collected job
        // result, so we might be able to progess other nodes
        // in the tree (or ourself) so make sure our update()
        // gets called as soon as executor has room for more
        // jobs
        awaiting_.add(e.executorNotBusyJob());
      }
    }
  }
};

}
