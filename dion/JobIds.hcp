// Copyright (c) 2020 Trevor Taylor
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all.
// Trevor Taylor makes no representations about the suitability of this
// software for any purpose.  It is provided "as is" without express or
// implied warranty.
//


#include <dion/JobId.hh>
#include <cinttypes>

namespace dion
{

// Set of a limited range [0..JobIds::maxJobId_] of JobId
class JobIds
{
public:
  explicit JobIds(uint64_t value=0):
      value_(value)
  {
  }
  // pre: x <= maxJobId__
  // post: onlyJob() == x
  explicit JobIds(JobId const& x):
      value_(1 << x.value())
  {
    xju::assert_less_equal(x, maxJobId_);
  }
  // pre: count() == 1
  JobId onlyJob() const noexcept
  {
    uint64_t value(value_);
    for(JobId i=JobId(0); i <= JobIds::maxJobId_; ++i){
      if (value_ & 1UL){
        xju::assert_equal(value_, 1UL);
        return i;
      }
    }
    xju::assert_never_reached(); // should have been a job
  }
  JobIds& remove(JobIds const& y) noexcept
  {
    value_ = value_ & ~y.value_;
    return *this;
  }

  JobIds& add(JobIds const& y) noexcept
  {
    value_ = value_ + ~y.value_;
    return *this;
  }

  static const JobId maxJobId_=JobId(sizeof(uint64_t)*8-1);

  // how many JobIds in set
  unsigned int count() const noexcept; // not implemented

private:
  uint64_t value_;

  friend JobIds operator-(JobIds const& a, JobIds const& b)
  {
    JobIds result(a);
    result.remove(b);
    return result;
  }
  friend JobIds operator+(JobIds const& a, JobIds const& b){
    return JobIds(a.value_ | b.value_);
  }
  friend JobIds operator&(JobIds const& a, JobIds const& b){
    return JobIds(a.value_ & b.value_);
  }
  friend bool operator<(JobIds const& a, JobIds const& b) noexcept;
};

}
