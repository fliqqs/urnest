- :dirtree:allfiles
  - seem to use that quite often and it is not obvious how it works
    doing it in the Odinfile

~ might be able to put back :cast_hash_incable (not worth it)
  - instead, discuss :cpp scalability issue

- remove ar stuff from cxx, make cxx.sm an sm
  .cxx.sm => .cxx.exe derivation to distinguish
  .c.sm => .c.exe 
  - no .sm => .exe

- don't hard-code which path, and test for which separately, eg ld.sh

- extract_dir:
  - if no files, extract all
  - extracted is directory -> error
  - extracted is soft-link -> warning+ignore
- add :cast.tree

- fix example in vir_tree.dg comments

- catch malformed in vir_tree.py (eg leading /)

- too many files executable

- resource temporarily unavailable

- sm.hash_inc_all

- add more explanations/examples in doc, doc more of the semantics
  of eg param handling (ordering, propogation); include more
  examples

- add ODINPKGLIST allowing explicit list of package names to load,
  as list of directories (allowing bash expansion)

- code package: append to archive

- cxx/cc link via .ar to handle long lists

- :LIST +path=(x/y/z):subdir => vir_tree.spec
  ie make a vir_tree.spec placing listed files in the x/y/z subdirectory
  (produces a spec so that can combine multiple of these statements via :cat)

- :DIRECTORY :find deriv could take a real find expression and
  apply it recursively (adding maxdepth=1 at each level)
  only need to note that nested virtual directories tend to be soft
  links rather than actual directories (could translate the find
  expression to account for this?)

x what does <:src> mean? doc is incomprehensible to me
  - 1 for source types, eg:
      :x => :FILE;
      :xa => :x;
      :xb => :x;
      *.xa => :xa;
      *.xb => :xb;
      :y => :FILE;
      :ya => :y;
      :yb => :y;

      EXEC /bin/cp (:xa) 'ya' => (:ya);
      EXEC /bin/cp (:xb) 'yb' => (:yb);

      - what does DG look like?
        equiv from xa to x
        equiv from x to xa
        equiv from xb to x
        equiv from x to xb
        equiv from ya to y
        equiv from y to ya
        equiv from yb to y
        equiv from y to yb

      - can I do 1.xa :yb (which would be the case if :xa is really
        equivalent to :xb)?

       NO. equiv is one-way, like cast, see DG.log bottom

x can't have :hash_inc work off FILE, because everything is a file, eg
  cxx*:exe which uses +define etc
  - define a :hash_incable and make selected file types hash_incable, eg:
    :cxx :c :h :idl
    (note :h is defined in cxx_impl)
    :idl not defined

- update vanilla odin packages:
  x add hash_inc
  x make :IDL and :h hash_incable
  - find all the vanilla packages
    that use :all_c_inc and its clones (eg cpp.dg) and point them
    at :hash_inc_all, or replace them with xju packages
        x code
        x cc
        x cpp
        cxx
        odi
        f77
        lex
        yacc
        tregrm
        dg
        idl
        prof
        lint
        misc
        roff
        tex
        dbx
        run
  ~ move my "stable" packages into odin-1.17.10x/pkg and document
    them in the manual
    - actually, put my packages in xjupkg and have doc point to
      where they are documented (eg Annex of manual), 
      - move pkg to xjupkg
      - reinstate vanilla pkg, careful not to clobber my necessary
        changes eg to odin package, dg package, others?
      (that turned out to be too much effort, better to just
       put a forked odin up on the net... nobody will ever use it
       anyway)

x cc
x code
x config (not copied to xjupkg)
cpp
cxx
dbx
dg
f77
hash_inc
idl
lex
lint
misc
odi
odin
PKGLST
prof
roff
run
tex
tregrm
vc
yacc
PKGLST
        
      - test configure and INSTALL
      - adjust INSTALL to install xjupkg, add odin --xjupkg option
        to use those instead of vanilla
      - confidence check
      - add a configure option to make them the default
      - continue with list of merges above (to eventualy get rid of
        my odin/pkg directory
      - add -ptr check to configure
    - put vanilla odin packages back to retain compatibility
      with existing users (then my changes are more likely to be
      merged back into vanilla odin)
    - note in odin manual tutorial any differences

  - make cxx/cc package link via .a to avoid name shortening silliness
    (like cxx)

  - adjust cpp use of all_c_inc - no +home

~ add x to all package versions where package is now non-vanilla

- idl package:
  .idl.sm -> .idl.h.list or virdir or something
  .idl.sm -> .idl.cxx.sm
  ... so that can generate all headers then
  put them into a virtual subtree for relative path includes
  - this aligns with having several .idl files in each directory
- separate omniidl / taoidl packages that know about the generation
  style? Yes I think so.

- odin shell script:
  x say "installing Tool Package x/y/y.dg" to tie in with odin manual and
    lead user to the .dg file rather than just a directory full of files
  - allow finer control over package list, eg explicitly list .dg files
    to load (ODINPKGLIST) and/or explicitly exclude packages by name
    ODINPKGSKIP
  - group packages into "boot" (those needed to INSTALL), "core" (those
    needed to run) and the rest (perhaps just as documentation alongside
    ODINPKGLIST)
  - update emacs integration, and give a discussion (files in etc)
    - note emacs integration has a deadlock when saving file while
      compiling

- update odin manual

- odin packages are self-documenting but need cookbook/tutorial/example
  information somewhere (odin/example directory?), needs to be searchable
  ie indexed by google (eg blog posts)

- add scp to misc package
- add gdb package like dbx? Just delete dbx - can do
  (.)+cmd=gdb (%exe) :run!
- rewrite idl to allow a idl.sm :cxx.sm and idl.sm :cxxheaders (which 
  produces a vir_dir with all headers generated from idl compile)
  - and idl.sm :py.sm, :c.sm
  .. or maybe write an omniorb package, since that is direct and would
     allow anyone to use as basis for their own
  (in fact that might be a good way to go in general, instead of
   cxx trying to cope with all compilers, just have a gcc package,
   a vc package etc... downside it would hard to use them both in
   same cache - unless perhaps have .vcxx.sm, .gcxx.sm etc

x best way to debug:
  odin -s
    x starts server process
  in another window ps -ef | grep odin
    x shows one server process
  in emacs, gdb attaching to that process
  b Local_Get_OdinFile

  in odin -s window:
    dir=/data/xju/tmp
    f1.x+a=1+b=2:y
    ... should hit the breakpoint
    
x step/next to get to this point:
#0  Do_Deriv (FilHdr=0x9469948, InhFilPrm=0x9468bc8, PrecFilPrm=0x946c8e0, ToFilTyp=0x9451cb8) at if-candrv.c:181
#1  0x0804bd42 in Apply_OprNods (FilHdr=0x9469948, FilPrm=0x946c8e0, OprNod=0x946b3a8) at if-candrv.c:548
#2  0x0804c123 in Nod_PrmFHdr (Nod=0x946b3c0) at if-candrv.c:641
#3  0x0804c5d9 in Local_Get_OdinFile (OdinExpr=0xbf8a8fd8 "f1.x +a=1 +b=2 :y", NeedsData=0) at if-candrv.c:787

x at this point:
    FilHdr represents the host file f1.x
    InhFilPrm is head of list of params
    PrecFilPrm is tail of list of params
    the list is ->Son->Son...

  ... which can be seen by:
(gdb) p (*(*(*RootFilPrm).Son).PrmTyp)
$25 = {PTName = 0x9466480 "a", Desc = 0x9466490 "param a", HelpLevel = 2, FilTyp = 0x9451718, RootLocPVal = 3848, StrDirLocHdr = 3574, Mark = 0, IPrmTyp = 4}
(gdb) p (*(*(*(*RootFilPrm).Son).Son).PrmTyp)
$26 = {PTName = 0x94664a0 "b", Desc = 0x94664b0 "param b", HelpLevel = 2, FilTyp = 0x9451718, RootLocPVal = 4158, StrDirLocHdr = 3884, Mark = 0, IPrmTyp = 5}

... and we can step through to:

148			  DrvFilPrm = Strip_FilPrm(FilPrm, PrmTypLst); };}/*select*

... and I reckon this will take a+b (in FilPrm) and reduce that to just a.

... more interesting would be a bit before, where we get PrmTypLst:

	    PrmTypLst = DrvPth_PrmTypLst(DrvPthElm);



with map, derivations are much more complicated:

=> f.x.sm+a=1+b=1:y.sm.list
** Generating /data/xju/tmp/f.x.sm +a=1 +b=1 :x*y.sm.list
** Generating /data/xju/tmp :odin*targets_ptr
** Generating /data/xju/tmp/Odinfile :odin*targets_ptr
** Generating /data/xju/tmp :odin*act_tgt.list
** Generating /data/xju/tmp/f.x.sm :x*x.sm.list
** Generating /data/xju/tmp/f.x.sm :x*x.sm.list +a=1 +b=1 :map=:y
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x :odin*targets_ptr
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x/Odinfile :odin*targets_ptr
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x :odin*act_tgt.list
** Generating /data/xju/tmp/ocnopkg/xjutv/PRM +a=1 :odin*prm_values
** Generating /data/xju/tmp/ocnopkg/xjutv/PRM +a=1 :odin*prm_values :odin*ls
** Generating /data/xju/tmp/f1.x +a=1 :x*y
** Executing : '/data/xju/tmp/ocnopkg/xjutv/PKGS/x/y.sh' '/data/xju/tmp/f1.x' '/data/xju/tmp/ocnopkg/xjutv/FILES/PRM.6871.ls'
=> f.x.sm+a=1+b=1:y.sm.list+depend=f.x.sm!:dpath
=> f.x.sm+a=1+b=1:y.sm.list+depend=(f.x.sm)!:dpath
2654    - /data/xju/tmp/f.x.sm
   is an input of:
3768    - /data/xju/tmp/f.x.sm :x*x.sm.list
   is an input of:
4136    - /data/xju/tmp/f.x.sm :x*x.sm.list +a=1 +b=1 :map=:y
   is an element of:
3932    - /data/xju/tmp/f.x.sm +a=1 +b=1 :x*y.sm.list


... and the initial Do_Deriv is short, but it gets called again a few times

eventually one has Make_MapLocElm in it, which might be interesting,

(gdb) up
#4  0x0804c574 in Make_MapLocElm (FilHdr=0x932cc18, ListFilHdr=0x932ce28) at if-candrv.c:764
... but it has already spat out:
** Generating /data/xju/tmp/f.x.sm :x*x.sm.list +a=1 +b=1 :map=:y
... so has already decided that :map=:y needs both params


x cpp.dg looks like might cause trouble, based on DG.log in the $ODIN cache,
at least I will remove the gmc.cpp deriv since it uses +define in a
derivation that produces a GENERIC ... but that doesn't fix the original problem (it might be part of the fix)

In this stack trace:

bt
#0  Do_Deriv (FilHdr=0x99f7708, InhFilPrm=0x99f8328, PrecFilPrm=0x99f3f98, ToFilTyp=0x99dcf40) at if-candrv.c:181
#1  0x0805ee48 in Do_InpSpc (BaseFilHdr=0x99f7708, InhFilPrm=0x99f8328, InpSpc=0x99e9970, Tool=0x99e38f8) at if-filinp.c:569
#2  0x0805f0c4 in Get_LocInp (FilHdr=0x99f8358) at if-filinp.c:637
#3  0x08059736 in Insert_FilHdr (BaseFilHdr=0x99f7708, FKind=8, FilTyp=0x99dcef8, FilPrm=0x99f8328, Ident=0x0) at if-fhnew.c:87
#4  0x080599bf in Extend_FilHdr (BaseFilHdr=0x99f7708, FKind=8, FilTyp=0x99dcef8, FilPrm=0x99f8328, IdentStr=0x0) at if-fhnew.c:147
#5  0x08059a3a in Get_Drv (BaseFilHdr=0x99f7708, FKind=8, FilTyp=0x99dcef8, FilPrm=0x99f8328, Ident=0x0) at if-fhnew.c:174
#6  0x0804b0a9 in Do_DrvPth (FilHdr=0x99f7708, InhFilPrm=0x99f3f98, PrecFilPrm=0x99f8328, DrvPth=0x99f7648) at if-candrv.c:155
#7  0x0804b1e5 in Do_Deriv (FilHdr=0x99f7708, InhFilPrm=0x99f3f98, PrecFilPrm=0x99f8328, ToFilTyp=0x99dcd90) at if-candrv.c:197
#8  0x0804bd42 in Apply_OprNods (FilHdr=0x99f7708, FilPrm=0x99f8328, OprNod=0x99f8058) at if-candrv.c:548
#9  0x0804c123 in Nod_PrmFHdr (Nod=0x99f8070) at if-candrv.c:641
#10 0x0804c5d9 in Local_Get_OdinFile (OdinExpr=0xbfd67a68 "/data/xju/tmp/f.x.sm :x*x.sm.list +a=1 +b=2 :y.sm.list", NeedsData=0) at if-candrv.c:787
#11 0x08074db3 in Get_OdinFile (FileName=0xbfd6799c "", StatusPtr=0xbfd67a64, ExecFlagPtr=0xbfd67998, OdinExpr=0xbfd67a68 "/data/xju/tmp/f.x.sm :x*x.sm.list +a=1 +b=2 :y.sm.list", NeedsData=0) at stub-out.c:529
#12 0x0804e3ee in Do_ShowStatus (AbortPtr=0xbfd693d8, Root=0x99f62d0) at if-cmd.c:253
#13 0x0804f1cd in Do_Command (AbortPtr=0xbfd693d8, Root=0x99f62d0, Interactive=1) at if-cmd.c:585
#14 0x0804f3fa in CommandInterpreter (AbortPtr=0xbfd693d8, Root=0x99f62d0, Interactive=1) at if-cmd.c:646
#15 0x08069770 in TopLevelCI (AbortPtr=0xbfd693d8, Str=0xbfd6870c "/data/xju/tmp/f.x.sm :x*x.sm.list +a=1+b=2:y.sm.list") at if-main.c:47
#16 0x08067439 in IPC_Get_Commands (AbortPtr=0xbfd693d8, Prompt=0x807d3fe "=> ") at if-ipc.c:489
#17 0x080697df in Get_Commands (AbortPtr=0xbfd693d8) at if-main.c:66
#18 0x08069921 in main (argc=2, argv=0xbfd69494) at if-main.c:120
(gdb) 

at #1:

	    FilHdr = Do_Deriv(FilHdr, InhFilPrm, PrecFilPrm, OpInpSpc->FilTyp);

... we have InhFilPrm+PrecFilPrm is a list of +a=1+b=1
OpInpSpc->FilTyp->FTName is "map"
OpInpSpc->FilTyp->ArgFilTyp->FTName is "y"
... that looks like what we're interested in (+a=1+b=1:map=:y)

... we then do Get_DrvPth and then move on to Do_DrvPth:

#0  Do_DrvPth (FilHdr=0x99f7708, InhFilPrm=0x99f8328, PrecFilPrm=0x99f3f98, DrvPth=0x99f7668) at if-candrv.c:140

... and it does the usual and calls:
DrvPth_PrmTypLst
... which chooses:
   if (DrvEdg != NIL) {
      return DrvEdg_PrmTypLst(DrvEdg); }/*if*/;

... but DrvEdg_PrmTypLst returns 0x0 as the PrmTypLst?

... when we get back to Do_DrvPth we choose:
	       if (IsGroupingInput_FilTyp(FilTyp)) {
		  DrvFilPrm = FilPrm;

... and we don't use the PrmTypLst, instead we go straight to:
	    FilHdr = Get_Drv(FilHdr, FKind, FilTyp, DrvFilPrm, DfltIdent);
... with:
FilTyp is our :map=:y
DrvFilPrm is end of our +a=1+b=1 list


x alas there is no function to find all the drvpths that lead to y (such as would
allow us to collect up all the applicable parameter types)

x obviously the info is in the graph, but on the surface it would appear tricky
  to build one... perhaps not: DG.log spits out all possible
  derivations, which should allow us to build our own "reverse" graph, either
  on-the-fly when loading DG or save to DG (or another file even)

x in DG.log there is an explicit map=:xy entry (which shows what can
  be derived from map=:xy)
x in DG.log there is a OBJECT -> map=:xy listed, and it has
  no attached params: we want to fill in the params
x all -> map=* entries have OBJECT as their source type (I would have
  expected LIST? Should not make any difference.)
x can see in dg-filtyp.c where it prints 'Possible Derivations :' then
  loops through each, and it will be the DrvEdg that has the -> map=:xy
x DrvEdg.h has tps_DrvEdg which has:
    tp_FilTyp FilTyp
    tp_PrmTypLst PrmTypLst (0x0 for map FilTyp see above)

  for map FilType.Tool->TClass==TC_Map

  FilType ":xy" is represented as tp_FilTyp ArgFilTyp and so will always be
  a single type (ie :xy never :z:xy) I think. And the ArgFilTyp.FTName should be
  ":xy".

  x want to adjust PrmTypLst just before writing out DG / DG.log (and before
    dumping 'Possible Derivations):

    dg-main.c calls a Make_PrmTypLsts, perhaps should adjust that?
      it is in dg-analyze.c
      - yes, add a step at the end, perhaps call it 
        void Set_TC_Map_DrvEdg_PrmTypLst(tp_FilTyp FilTyp)
        ... assuming that reverse mappings has been pre-built, eg by
        Build_TC_Map_PrmTypLst_Info(tp_FilTyp begin)
           - which would build from drv, eqv and cast edges (see dg-filtyp.c
             Print_Info for how to go through those)

  x test that:
    x figure out which dg.exe is used to create cache
    x update it
    x create cache
    x step through above code and see if DrvEdg_PrmTypLst returns 0x0
      (see above)

  x then just need to adjust Do_DrvPth (see above)

... after adjustment, get following, note difference in Generating...:map=:xy line, it now does not mention b, so I think we've won:

=>  f.x.sm+a=1+b=2:xy.sm.list
** Generating /data/xju/tmp/f.x.sm +a=1 +b=2 :x*xy.sm.list
** Generating /data/xju/tmp :odin*targets_ptr
** Generating /data/xju/tmp/Odinfile :odin*targets_ptr
** Generating /data/xju/tmp :odin*act_tgt.list
** Generating /data/xju/tmp/f.x.sm :x*x.sm.list
** Generating /data/xju/tmp/f.x.sm :x*x.sm.list +a=1 :map=:xy
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x :odin*targets_ptr
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x/Odinfile :odin*targets_ptr
** Generating /data/xju/tmp/ocnopkg/xjutv/PKGS/x :odin*act_tgt.list
** Generating /data/xju/tmp/ocnopkg/xjutv/PRM +a=1 :odin*prm_values
** Generating /data/xju/tmp/ocnopkg/xjutv/PRM +a=1 :odin*prm_values :odin*ls
** Generating /data/xju/tmp/f1.x +a=1 :x*xy
** Executing : '/data/xju/tmp/ocnopkg/xjutv/PKGS/x/y.sh' '/data/xju/tmp/f1.x' '/data/xju/tmp/ocnopkg/xjutv/FILES/PRM.6871.ls'
=> 

- a confidence check:

./configure  && ./CLEAN && ./INSTALL /data/xju/u1 && PATH=/data/xju/u1/bin:$PATH ../create-linux-cache.sh /data/xju/tmp/u1c && ODIN=/data/xju/tmp/u1c /data/xju/u1/bin/odin pkg/cpp%test1 ../../xju%run-standalone-tests
