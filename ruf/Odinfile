%all == %all.tree:leaves

%all.tree == <<
%test-tree.output
%test-refs.output
%test-cssish-selector.output
%test-rs-dep-1
%test-rs-dep-2
%test-rs-dep-3

%ropts == <<
+cmd=rustc -A dead_code

%test-tree == ()+(%ropts) +cmd=-o test-tree -g (test-tree.rs) +need=(tree.rs) (assert.rs) (mod.rs):output/test-tree
%test-tree.output == ()+cmd=RUST_BACKTRACE\=full (%test-tree):exec.output

%test-refs == ()+(%ropts) +cmd=-o test-refs -g (test-refs.rs):output/test-refs
%test-refs.output == ()+cmd=RUST_BACKTRACE\=full (%test-refs):exec.output

%test-context == ()+(%ropts) +cmd=-o test-context -g  -L (../../anyhow/target/debug) (test-context.rs) +need=(../../anyhow/target/debug/libanyhow.rlib):output/test-context
%test-context.output == ()+cmd=RUST_BACKTRACE\=full (%test-context):exec.output

%test-cssish-selector == ()+(%ropts) +cmd=-o test-cssish-selector -g (test-cssish-selector.rs) +need=(tree.rs) (assert.rs) (mod.rs):output/test-cssish-selector
%test-cssish-selector.output == ()+cmd=RUST_BACKTRACE\=full (%test-cssish-selector):exec.output

%rs-dep == (rs-dep.cc)+(..%cxx-opts):auto.cxx.exe

%test-rs-dep-1 == ()+cmd=(%rs-dep) -L (%test-rs-crate-dirs:list:ls) (%rs1):exec.output
%test-rs-dep-2 == ()+cmd=(%rs-dep)+cmd=(test-tree.rs):exec.output
%test-rs-dep-3 == ()+cmd=(%rs-dep)+cmd=(test-context.rs):exec.output

%test-rs-crate-dirs == <<
(.)
(..)

#REVISIT: need a test for rs-dep on file called mod.rs

%rs1 == <<
mod x;
#[path="fred/y.rs"]
pub mod y;
pub mod z { }
pub mod q {
  #[path="src/q/qq.rs"]
  pub mod y;
}
extern crate julie;
use ruf::tree;
pub fn a(y: i32) -> i32 { 1 }
extern "C" fn a(y: i32) -> i32 { 1 }
extern r##"c#"## fn a(y: i32) -> i32 { 1 }
type x = i32;
struct UnitStruct;
struct TupleStruct(i32, i32)
struct RegularStruct{ x: i32, y: String}
enum Enum{ Dog(String, f64), Cat { name: String, weight: f64 },x: i32}
union MyUnion { f1: u32, f2: f32, }
#[repr(C)] union MyUnion { f1: u32, f2: f32, }
const BIT1: u32 = 1 << 0;
const BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings { mybits: BITS, mystring: STRING, };
static COUNTER: AtomicUsize = AtomicUsize::new(0);
trait Example { const CONST: i32; fn method(&self); fn method_with_dflt(&self) {} }
impl Color { pub const WHITE: Color = Color(255, 255, 255); }
unsafe extern "stdcall" { }
//
// from rust reference modules section
mod inline {
    #[path = "other.rs"]
    mod inner;
}
#[path = "thread_files"]
mod thread {
    // Load the `local_data` module from `thread_files/tls.rs` relative to
    // this source file's directory.
    #[path = "tls.rs"]
    mod local_data;
}
